// Export Utilities for TPV Studio
// SVG, PNG, DXF, and PDF exports

import sharp from 'sharp';
import { createClient } from '@supabase/supabase-js';

// Load TPV palette colors
const TPV_PALETTE = {
  'TPV01': '#000000', 'TPV02': '#FFFFFF', 'TPV03': '#808080',
  'TPV04': '#C0C0C0', 'TPV05': '#8B4513', 'TPV06': '#D2691E',
  'TPV07': '#CD853F', 'TPV08': '#4169E1', 'TPV09': '#00008B',
  'TPV10': '#ADD8E6', 'TPV11': '#40E0D0', 'TPV12': '#006400',
  'TPV13': '#228B22', 'TPV14': '#90EE90', 'TPV15': '#FFFF00',
  'TPV16': '#FFD700', 'TPV17': '#FFA500', 'TPV18': '#FF4500',
  'TPV19': '#FF0000', 'TPV20': '#8B008B', 'TPV21': '#FF69B4'
};

/**
 * Convert polygon points to SVG path string
 */
function pointsToPath(points) {
  if (!points || points.length === 0) return '';

  const pathParts = points.map((p, i) => {
    const command = i === 0 ? 'M' : 'L';
    return `${command} ${p.x.toFixed(3)},${p.y.toFixed(3)}`;
  });

  pathParts.push('Z'); // Close path

  return pathParts.join(' ');
}

/**
 * Export design to SVG
 */
export function exportSVG(regions, surface, metadata = {}) {
  const { width_m, height_m } = surface;

  // Group regions by color
  const layersByColor = {};
  for (const region of regions) {
    const color = region.color || 'TPV08';
    if (!layersByColor[color]) {
      layersByColor[color] = [];
    }
    layersByColor[color].push(region);
  }

  // Build SVG with layers
  const layers = [];

  for (const [color, colorRegions] of Object.entries(layersByColor)) {
    const hexColor = TPV_PALETTE[color] || '#4169E1';
    const paths = colorRegions.map(region =>
      `    <path d="${pointsToPath(region.points)}" fill="${hexColor}" />`
    ).join('\n');

    layers.push(
      `  <g id="layer-${color}" data-color="${color}">\n${paths}\n  </g>`
    );
  }

  // Build complete SVG
  const svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg"
     width="${width_m}m"
     height="${height_m}m"
     viewBox="0 0 ${width_m} ${height_m}"
     data-tpv-studio="1.0"
     data-title="${metadata.title || 'TPV Design'}"
     data-variant="${metadata.variant || 1}">
  <title>${metadata.title || 'TPV Design'}</title>
  <desc>Generated by TPV Studio - Rosehill Group</desc>

  ${layers.join('\n\n')}
</svg>`;

  return svg;
}

/**
 * Export SVG as PNG using sharp
 */
export async function exportPNG(svgContent, width = 1200) {
  try {
    const pngBuffer = await sharp(Buffer.from(svgContent))
      .resize(width, null, { fit: 'contain', background: { r: 255, g: 255, b: 255, alpha: 1 } })
      .png()
      .toBuffer();

    return pngBuffer;
  } catch (error) {
    console.error('[EXPORT PNG] Error:', error);
    throw new Error(`PNG export failed: ${error.message}`);
  }
}

/**
 * DXF Export Stub
 * Returns basic DXF header for now
 */
export function exportDXF(regions, surface) {
  // Week 1 MVP: Basic stub
  // Full implementation would use dxf-writer or similar
  const { width_m, height_m } = surface;

  const dxf = `0
SECTION
2
HEADER
9
$INSUNITS
70
4
0
ENDSEC
0
SECTION
2
ENTITIES
999
TPV Studio Export - R2013 Format
999
Surface: ${width_m}m x ${height_m}m
999
Regions: ${regions.length}
0
ENDSEC
0
EOF`;

  return dxf;
}

/**
 * PDF Export Stub
 * Returns basic PDF metadata for now
 */
export function exportPDF(regions, surface, bom) {
  // Week 1 MVP: Basic stub
  // Full implementation would use pdfkit
  return {
    format: 'pdf',
    surface: `${surface.width_m}m x ${surface.height_m}m`,
    regions: regions.length,
    bom: bom,
    note: 'Full PDF export with installation plan coming in Week 2'
  };
}

/**
 * Upload file to Supabase Storage
 * Returns public URL
 */
export async function uploadToStorage(buffer, filename, bucketName = 'tpv-studio') {
  const supabase = createClient(
    process.env.SUPABASE_URL,
    process.env.SUPABASE_SERVICE_ROLE || process.env.SUPABASE_SERVICE_KEY
  );

  try {
    // Generate unique path: designs/YYYYMMDD/filename
    const date = new Date().toISOString().split('T')[0].replace(/-/g, '');
    const path = `designs/${date}/${filename}`;

    console.log('[UPLOAD] Uploading to:', bucketName, path);

    // Upload file
    const { data, error } = await supabase.storage
      .from(bucketName)
      .upload(path, buffer, {
        contentType: getContentType(filename),
        upsert: true
      });

    if (error) {
      throw error;
    }

    // Get public URL
    const { data: { publicUrl } } = supabase.storage
      .from(bucketName)
      .getPublicUrl(path);

    console.log('[UPLOAD] Success:', publicUrl);

    return publicUrl;
  } catch (error) {
    console.error('[UPLOAD] Error:', error);
    throw new Error(`Upload failed: ${error.message}`);
  }
}

/**
 * Get content type from filename
 */
function getContentType(filename) {
  const ext = filename.split('.').pop().toLowerCase();
  const types = {
    'svg': 'image/svg+xml',
    'png': 'image/png',
    'dxf': 'application/dxf',
    'pdf': 'application/pdf',
    'json': 'application/json'
  };
  return types[ext] || 'application/octet-stream';
}

/**
 * Generate all exports for a variant
 * Returns URLs for each format
 */
export async function generateAllExports(regions, surface, metadata, bom) {
  const variantId = `v${metadata.variant}_${Date.now()}`;

  try {
    // Generate SVG
    const svg = exportSVG(regions, surface, metadata);
    const svgUrl = await uploadToStorage(
      Buffer.from(svg, 'utf8'),
      `${variantId}.svg`
    );

    // Generate PNG from SVG
    const pngBuffer = await exportPNG(svg, 1200);
    const pngUrl = await uploadToStorage(
      pngBuffer,
      `${variantId}.png`
    );

    // Generate DXF stub
    const dxf = exportDXF(regions, surface);
    const dxfUrl = await uploadToStorage(
      Buffer.from(dxf, 'utf8'),
      `${variantId}.dxf`
    );

    // Generate PDF stub (just metadata for now)
    const pdfData = exportPDF(regions, surface, bom);
    const pdfUrl = await uploadToStorage(
      Buffer.from(JSON.stringify(pdfData, null, 2), 'utf8'),
      `${variantId}.pdf.json`
    );

    return {
      svgUrl,
      pngUrl,
      dxfUrl,
      pdfUrl
    };
  } catch (error) {
    console.error('[EXPORTS] Error generating exports:', error);
    throw error;
  }
}
