<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rosehill TPV® Colour Mixer - Create Custom Granule Blends</title>
    <meta name="description" content="Interactive colour mixing tool for Rosehill TPV® rubber granules. Create custom colour blends, preview designs, and generate professional reports with material calculations.">
    <meta name="keywords" content="TPV colour mixer, rubber granule mixer, custom color blends, surface design tool, color mixing tool, TPV granule calculator, surface visualization, custom surface colors, Rosehill color mixer, granule proportions">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://tpv.rosehill.group/mixer.html">
    <meta property="og:title" content="Rosehill TPV® Colour Mixer - Create Custom Granule Blends">
    <meta property="og:description" content="Interactive colour mixing tool for Rosehill TPV® rubber granules. Create custom colour blends, preview designs, and generate professional reports with material calculations.">
    <meta property="og:image" content="https://tpv.rosehill.group/rosehill_tpv_social_sharing.jpg">
    <meta property="og:site_name" content="Rosehill TPV®">
    <meta property="og:locale" content="en_US">
    
    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://tpv.rosehill.group/mixer.html">
    <meta name="twitter:title" content="Rosehill TPV® Colour Mixer - Create Custom Granule Blends">
    <meta name="twitter:description" content="Interactive colour mixing tool for Rosehill TPV® rubber granules. Create custom colour blends, preview designs, and generate professional reports with material calculations.">
    <meta name="twitter:image" content="https://tpv.rosehill.group/rosehill_tpv_social_sharing.jpg">
    <meta name="twitter:site" content="@RosehillTPV">
    
    <!-- JSON-LD Structured Data -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "SoftwareApplication",
        "name": "Rosehill TPV® Colour Mixer",
        "description": "Interactive web-based tool for creating custom TPV® rubber granule color blends with real-time visualization and professional reporting",
        "url": "https://tpv.rosehill.group/mixer.html",
        "applicationCategory": "Design Tool",
        "applicationSubCategory": "Color Mixing Tool",
        "operatingSystem": "Web Browser",
        "browserRequirements": "Modern web browser with JavaScript enabled",
        "memoryRequirements": "512MB RAM",
        "storageRequirements": "No storage required - runs in browser",
        "permissions": "No special permissions required",
        "softwareVersion": "2.0",
        "datePublished": "2024-01-01",
        "dateModified": "2024-12-01",
        "author": {
            "@type": "Organization",
            "name": "Rosehill TPV®",
            "url": "https://tpv.rosehill.group"
        },
        "publisher": {
            "@type": "Organization", 
            "name": "Rosehill TPV®",
            "url": "https://tpv.rosehill.group"
        },
        "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "GBP",
            "availability": "https://schema.org/InStock",
            "description": "Free online tool for TPV® color mixing and visualization"
        },
        "featureList": [
            "Interactive color selection from 21 TPV® granule colors",
            "Real-time visual mixing and blending",
            "Custom proportion adjustment with live preview",
            "Professional PDF report generation",
            "Material calculation and quantity estimation", 
            "Shareable project codes for collaboration",
            "3D surface visualization",
            "Export and save functionality"
        ],
        "screenshot": {
            "@type": "ImageObject",
            "url": "https://tpv.rosehill.group/rosehill_tpv_social_sharing.jpg",
            "caption": "Rosehill TPV® Color Mixer interface"
        },
        "softwareHelp": {
            "@type": "CreativeWork",
            "name": "Color Mixer User Guide",
            "description": "Interactive help system built into the application"
        },
        "applicationSuite": "Rosehill TPV® Design Tools",
        "downloadUrl": "https://tpv.rosehill.group/mixer.html",
        "installUrl": "https://tpv.rosehill.group/mixer.html",
        "softwareRequirements": [
            "JavaScript enabled browser",
            "Internet connection for initial load"
        ],
        "targetAudience": [
            {
                "@type": "Audience",
                "audienceType": "Sports Surface Designers"
            },
            {
                "@type": "Audience", 
                "audienceType": "Playground Designers"
            },
            {
                "@type": "Audience",
                "audienceType": "Architects"
            },
            {
                "@type": "Audience",
                "audienceType": "Surface Installation Contractors"
            }
        ],
        "usageInfo": {
            "@type": "CreativeWork",
            "name": "Design custom TPV® surface colors",
            "description": "Create unique color combinations for sports and playground surfaces with professional-grade mixing tools"
        }
    }
    </script>
    
    <link rel="canonical" href="https://tpv.rosehill.group/mixer.html">
    <link rel="apple-touch-icon" sizes="180x180" href="favicon_io/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon_io/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon_io/favicon-16x16.png">
    <link rel="manifest" href="favicon_io/site.webmanifest">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Overpass:wght@300;400;500;600;700&family=Source+Sans+Pro:wght@400;600;700&display=swap" rel="stylesheet">
    
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-5565Z2W7');</script>
    <!-- End Google Tag Manager -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/d3-delaunay@6.0.4/dist/d3-delaunay.min.js"></script>
    <script src="https://unpkg.com/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Source Sans Pro', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            color: #333;
            line-height: 1.6;
            margin-top: 70px; /* Account for fixed header */
        }

        /* Header Styles */
        .header {
            background: linear-gradient(135deg, #1a365d, #2d4a71);
            color: white;
            padding: 15px 0;
            position: fixed;
            width: 100%;
            top: 0;
            z-index: 1000;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }

        .header-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-size: 1.8rem;
            font-weight: 600;
            font-family: 'Source Sans Pro', sans-serif;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .nav-menu {
            display: flex;
            list-style: none;
            gap: 25px;
            align-items: center;
        }

        .nav-menu a {
            color: white;
            text-decoration: none;
            font-weight: 500;
            transition: all 0.3s ease;
            padding: 8px 16px;
            border-radius: 6px;
        }

        .nav-menu a:hover {
            background: rgba(255, 107, 53, 0.2);
            color: #ff6b35;
        }

        .nav-menu a.active {
            background: rgba(255, 107, 53, 0.2);
            color: #ff6b35;
            font-weight: 600;
        }

        /* Desktop Language Switcher Dropdown */
        .language-switcher-desktop {
            position: relative;
            display: inline-block;
        }

        .language-dropdown-toggle {
            color: white !important;
            text-decoration: none !important;
            font-weight: 500 !important;
            transition: all 0.3s ease !important;
            padding: 8px 16px !important;
            border-radius: 6px !important;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .language-dropdown-toggle:after {
            content: '▼';
            font-size: 10px;
            transition: transform 0.3s ease;
        }

        .language-dropdown-toggle.active:after {
            transform: rotate(180deg);
        }

        .language-dropdown-toggle:hover {
            background: rgba(255, 107, 53, 0.2) !important;
            color: #ff6b35 !important;
        }

        .language-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
            display: none;
            flex-direction: column;
            min-width: 120px;
            z-index: 1000;
            overflow: hidden;
            margin-top: 8px;
        }

        .language-dropdown.active {
            display: flex;
        }

        .language-dropdown .lang-option {
            padding: 12px 16px !important;
            color: #64748b !important;
            text-decoration: none !important;
            transition: all 0.2s ease !important;
            font-size: 14px !important;
            font-weight: 500 !important;
            border-radius: 0 !important;
            display: block;
        }

        .language-dropdown .lang-option:hover {
            background: #f8fafc !important;
            color: #1a365d !important;
        }

        .language-switcher-desktop .language-dropdown .lang-option.active {
            background: #ff6b35 !important;
            color: white !important;
        }

        .contact-btn {
            background: #ff6b35;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            margin-left: 10px;
        }

        .contact-btn:hover {
            background: #e55a2b !important;
            transform: translateY(-2px);
        }

        /* Mobile Menu */
        .mobile-menu-toggle {
            display: none;
            flex-direction: column;
            cursor: pointer;
            padding: 8px;
            background: none;
            border: none;
            z-index: 1001;
        }

        .mobile-menu-toggle span {
            width: 25px;
            height: 3px;
            background: white;
            margin: 3px 0;
            transition: 0.3s;
            border-radius: 2px;
        }

        .mobile-menu-toggle.active span:nth-child(1) {
            transform: rotate(-45deg) translate(-5px, 6px);
        }

        .mobile-menu-toggle.active span:nth-child(2) {
            opacity: 0;
        }

        .mobile-menu-toggle.active span:nth-child(3) {
            transform: rotate(45deg) translate(-5px, -6px);
        }

        .mobile-nav-menu {
            display: none;
            position: fixed;
            top: 70px;
            left: 0;
            right: 0;
            background: linear-gradient(135deg, #1a365d, #2d4a71);
            flex-direction: column;
            padding: 20px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
            z-index: 999;
        }

        .mobile-nav-menu.active {
            display: flex;
        }

        .mobile-nav-menu a {
            color: white;
            text-decoration: none;
            font-weight: 500;
            padding: 15px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            transition: color 0.3s ease;
        }

        .mobile-nav-menu a:hover {
            color: #ff6b35;
        }

        .mobile-nav-menu a.active {
            color: #ff6b35;
            font-weight: 600;
        }

        .mobile-nav-menu a:last-child {
            border-bottom: none;
        }

        .mobile-nav-menu .contact-btn {
            background: #ff6b35;
            padding: 15px 20px;
            border-radius: 8px;
            text-align: center;
            margin-top: 10px;
            border-bottom: none;
        }

        .app {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .app-header {
            text-align: center;
            margin-bottom: 30px;
            margin-top: 40px;
        }

        .app-header h1 {
            font-family: 'Overpass', sans-serif;
            font-size: 2.5rem;
            font-weight: 600;
            color: #1a365d;
            margin-bottom: 10px;
        }

        .main-content {
            display: flex;
            flex-direction: column;
            gap: 30px;
        }

        .canvas-container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
            position: relative;
        }

        .canvas-wrapper {
            position: relative;
            width: 100%;
            max-width: 1000px;
            height: 500px;
            margin: 0 auto;
            overflow: hidden;
            aspect-ratio: 2 / 1; /* Modern browsers: maintain 2:1 aspect ratio */
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255,255,255,0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            color: #666;
        }

        .zoom-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 5px;
            z-index: 100;
        }

        .zoom-btn {
            width: 36px;
            height: 36px;
            border: none;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .zoom-btn:hover {
            background: white;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }

        .zoom-btn:active {
            transform: translateY(0);
        }

        .zoom-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .zoom-btn svg {
            width: 20px;
            height: 20px;
        }

        .project-details-section {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
            margin-top: 20px;
        }

        .project-details-section h2 {
            font-family: 'Overpass', sans-serif;
        }

        .form-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 15px;
        }

        .form-field {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .form-field.full-width {
            grid-column: 1 / -1;
        }

        .form-label {
            font-weight: 600;
            color: #333;
            font-size: 0.9rem;
        }

        .form-input {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.9rem;
            transition: border-color 0.2s ease;
        }

        .form-input:focus {
            outline: none;
            border-color: #2196F3;
        }

        .form-textarea {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.9rem;
            resize: vertical;
            min-height: 60px;
            font-family: inherit;
            transition: border-color 0.2s ease;
        }

        .form-textarea:focus {
            outline: none;
            border-color: #2196F3;
        }

        .material-calc {
            background: #f8f9fa;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
            border-left: 4px solid #2196F3;
        }

        .material-calc h4 {
            font-family: 'Overpass', sans-serif;
            color: #333;
            margin-bottom: 10px;
            font-size: 1rem;
        }

        .material-amount {
            font-size: 1.1rem;
            font-weight: bold;
            color: #2196F3;
        }

        .color-materials-breakdown {
            margin: 10px 0;
        }

        .color-material-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #e9ecef;
        }

        .color-material-item:last-child {
            border-bottom: none;
            margin-bottom: 8px;
        }

        .color-material-info {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
        }

        .color-material-swatch {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            border: 1px solid #ddd;
            flex-shrink: 0;
        }

        .color-material-name {
            font-weight: 500;
            color: #333;
            font-size: 0.95rem;
        }

        .color-material-quantity {
            font-weight: 600;
            color: #2196F3;
            margin-right: 8px;
        }

        .color-material-percentage {
            font-size: 0.85rem;
            color: #666;
        }

        .material-total {
            border-top: 2px solid #2196F3;
            padding-top: 12px;
            margin-top: 8px;
            font-size: 1.1rem;
            font-weight: bold;
            color: #2196F3;
            text-align: center;
        }

        .btn-pdf {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 600;
            transition: all 0.3s ease;
            width: 100%;
        }

        .btn-pdf:hover {
            background: #c0392b;
            transform: translateY(-1px);
        }

        .btn-pdf:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        @media (max-width: 768px) {
            .form-grid {
                grid-template-columns: 1fr;
            }
        }

        .controls {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 30px;
            align-items: start;
        }

        .left-controls {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .right-controls {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        @media (max-width: 1024px) {
            .controls {
                grid-template-columns: 1fr;
            }
        }

        .palette-section {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 25px;
            width: 100%;
        }

        .palette-title {
            font-family: 'Overpass', sans-serif;
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 15px;
            color: #444;
        }

        .palette-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 12px;
            max-width: 1000px;
            margin: 0 auto;
        }

        @media (max-width: 1200px) {
            .palette-grid {
                grid-template-columns: repeat(5, 1fr);
                gap: 10px;
            }
        }

        @media (max-width: 768px) {
            .palette-grid {
                grid-template-columns: repeat(3, 1fr);
                gap: 8px;
            }
        }

        .colour-item {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .colour-swatch {
            width: 100%;
            height: 40px;
            border: 2px solid #e0e0e0;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .colour-swatch:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .colour-swatch.has-parts {
            border-color: #2196F3;
            border-width: 3px;
        }

        .colour-info {
            text-align: center;
        }

        .colour-name {
            font-size: 0.75rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 1px;
            line-height: 1.1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .colour-code {
            font-size: 0.65rem;
            color: #666;
            font-family: monospace;
        }

        .parts-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-top: 4px;
        }

        .parts-btn {
            width: 24px;
            height: 24px;
            border: none;
            border-radius: 50%;
            background: #2196F3;
            color: white;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .parts-btn:hover {
            background: #1976D2;
            transform: scale(1.1);
        }

        .parts-btn:active {
            transform: scale(0.95);
        }

        .parts-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .parts-count {
            min-width: 24px;
            text-align: center;
            font-weight: bold;
            font-size: 0.9rem;
            color: #333;
        }

        .mix-bar-section {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
        }

        .mix-bar-section h2 {
            font-family: 'Overpass', sans-serif;
        }

        .mix-bar {
            height: 40px;
            border-radius: 20px;
            overflow: hidden;
            display: flex;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 15px;
        }

        .mix-bar-segment {
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.9rem;
            font-weight: 500;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
        }

        .mix-bar-empty {
            flex: 1;
            background: #e0e0e0;
            color: #999;
            text-shadow: none;
        }

        .mix-details {
            display: grid;
            gap: 8px;
            max-height: 200px;
            overflow-y: auto;
        }

        .mix-detail-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            background: #f8f8f8;
            border-radius: 6px;
        }

        .mix-detail-colour {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            flex-shrink: 0;
        }

        .mix-detail-text {
            flex: 1;
            font-size: 0.9rem;
        }

        .action-buttons {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            background: #2196F3;
            color: white;
        }

        .btn:hover {
            background: #1976D2;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: #757575;
        }

        .btn-secondary:hover {
            background: #616161;
        }

        .share-section {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
        }

        .share-section h2 {
            font-family: 'Overpass', sans-serif;
        }

        .blend-preview-section {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
            margin-bottom: 20px;
        }

        .blend-preview-section h2 {
            font-family: 'Overpass', sans-serif;
        }

        .blend-preview-swatch {
            width: 100%;
            height: 80px;
            border-radius: 8px;
            border: 2px solid #e0e0e0;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-family: monospace;
            font-size: 1.1rem;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .blend-preview-swatch:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .blend-details {
            display: grid;
            gap: 8px;
        }

        .blend-detail-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
        }

        .blend-detail-label {
            color: #666;
        }

        .blend-detail-value {
            font-family: monospace;
            font-weight: 500;
            color: #333;
        }

        .share-input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-family: monospace;
            font-size: 0.9rem;
            margin-bottom: 10px;
        }

        .share-input:focus {
            outline: none;
            border-color: #2196F3;
        }

        .share-input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .share-input-field {
            flex: 1;
        }

        .btn-load {
            background: #28a745;
            padding: 10px 15px;
            white-space: nowrap;
        }

        .btn-load:hover {
            background: #218838;
        }

        .btn-load:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }

        .share-error {
            color: #dc3545;
            font-size: 0.85rem;
            margin-top: 5px;
        }

        .tile-preview-section {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
            margin-bottom: 20px;
        }

        .tile-preview-section h2 {
            font-family: 'Overpass', sans-serif;
        }

        .tile-preview-container {
            width: 100%;
            height: 250px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            margin-bottom: 15px;
            position: relative;
            overflow: hidden;
            background: linear-gradient(135deg, #f5f5f5, #e8e8e8);
            cursor: grab;
        }

        .tile-preview-container:active {
            cursor: grabbing;
        }

        .tile-preview-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .tile-preview-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #666;
            font-size: 0.9rem;
            z-index: 100;
        }

        .tile-preview-error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #dc3545;
            font-size: 0.9rem;
            text-align: center;
            z-index: 100;
        }

        .tile-preview-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
            color: #666;
        }

        .tile-preview-info {
            display: flex;
            gap: 15px;
        }

        .tile-preview-reset {
            background: #757575;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: background 0.2s;
        }

        .tile-preview-reset:hover {
            background: #616161;
        }

        .tile-zoom-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 100;
        }

        .tile-zoom-btn {
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            backdrop-filter: blur(5px);
        }

        .tile-zoom-btn:hover {
            background: rgba(255, 255, 255, 1);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }

        .tile-zoom-btn:active {
            transform: translateY(0);
        }

        .tile-zoom-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .tile-zoom-btn svg {
            width: 16px;
            height: 16px;
        }

        @media (max-width: 768px) {
            .tile-preview-container {
                height: 200px;
            }
            
            .tile-preview-controls {
                flex-direction: column;
                gap: 10px;
                align-items: flex-start;
            }
            
            .tile-preview-info {
                gap: 10px;
            }

            .tile-zoom-controls {
                top: 8px;
                right: 8px;
                gap: 4px;
            }

            .tile-zoom-btn {
                width: 36px;
                height: 36px;
                font-size: 18px;
                touch-action: manipulation;
            }
        }

        @media (max-width: 480px) {
            .tile-preview-container {
                height: 180px;
            }
        }

        .tooltip {
            position: absolute;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 0.85rem;
            pointer-events: none;
            z-index: 1000;
            white-space: nowrap;
        }

        @media (max-width: 768px) {
            .canvas-wrapper {
                height: auto; /* Let aspect-ratio control height */
                max-height: 400px;
                min-height: 200px;
            }
            
            /* Fallback for browsers without aspect-ratio support */
            @supports not (aspect-ratio: 2 / 1) {
                .canvas-wrapper {
                    height: 50vw; /* Maintain 2:1 aspect ratio (width:height) */
                }
            }
        }

        /* iPhone and small mobile devices in portrait */
        @media (max-width: 480px) {
            .canvas-wrapper {
                height: auto; /* Let aspect-ratio control height */
                max-height: 240px;
                min-height: 180px;
            }
            
            /* Fallback for browsers without aspect-ratio support */
            @supports not (aspect-ratio: 2 / 1) {
                .canvas-wrapper {
                    height: 50vw; /* Maintain 2:1 aspect ratio */
                }
            }
        }

        /* Very small devices */
        @media (max-width: 375px) {
            .canvas-wrapper {
                height: auto; /* Let aspect-ratio control height */
                max-height: 187px;
                min-height: 160px;
            }
            
            /* Fallback for browsers without aspect-ratio support */
            @supports not (aspect-ratio: 2 / 1) {
                .canvas-wrapper {
                    height: 50vw; /* Maintain 2:1 aspect ratio */
                }
            }
            
            .colour-swatch {
                height: 35px;
            }
            
            .colour-name {
                font-size: 0.7rem;
            }
            
            .colour-code {
                font-size: 0.6rem;
            }
            
            .parts-btn {
                width: 20px;
                height: 20px;
                font-size: 0.9rem;
            }
            
            .parts-count {
                font-size: 0.8rem;
                min-width: 20px;
            }
        }

        /* Container */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 20px;
        }

        /* Footer Styles */
        .footer {
            background: #1a365d;
            color: white;
            padding: 60px 0 30px;
            margin-top: 60px;
        }

        /* Footer Contact Icons */
        .footer-contact-info {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 10px;
        }

        .footer-contact-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .footer-contact-item a {
            color: white;
            text-decoration: none;
            transition: color 0.3s ease;
        }

        .footer-contact-item a:hover {
            color: #ff6b35;
        }

        .footer-icon {
            width: 16px;
            height: 16px;
            flex-shrink: 0;
        }

        .footer-icon svg {
            width: 100%;
            height: 100%;
            fill: white;
            transition: fill 0.3s ease;
        }

        .footer-contact-item:hover .footer-icon svg {
            fill: #ff6b35;
        }

        .footer-content {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 40px;
            margin-bottom: 40px;
        }

        .footer-section h3 {
            font-family: 'Overpass', sans-serif;
            font-size: 1.3rem;
            margin-bottom: 20px;
            color: #ff6b35;
        }

        .footer-section p,
        .footer-section li {
            opacity: 0.9;
            line-height: 1.8;
            margin-bottom: 10px;
        }

        .footer-section ul {
            list-style: none;
        }

        .footer-section a {
            color: white;
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .footer-section a:hover {
            color: #ff6b35;
        }

        .footer-bottom {
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 30px;
            text-align: center;
            opacity: 0.8;
        }

        /* Responsive styles for mobile menu */
        /* Hide desktop language dropdown on mobile */
        @media (max-width: 768px) {
            .language-switcher-desktop {
                display: none;
            }
        }

        /* Intermediate breakpoint for nav compression */
        @media (max-width: 1200px) and (min-width: 1101px) {
            .nav-menu {
                gap: 15px;
            }
            .nav-menu a {
                padding: 6px 12px;
                font-size: 0.95rem;
            }
            .contact-btn {
                padding: 10px 20px;
            }
        }

        @media (max-width: 1100px) {
            .nav-menu {
                display: none;
            }

            .mobile-menu-toggle {
                display: flex;
            }
        }
    </style>
</head>
<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5565Z2W7"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
    <!-- Header -->
    <header class="header">
        <div class="header-container">
            <a href="index.html" class="logo">
                <picture>
                <source srcset="rosehill_tpv_logo.webp" type="image/webp">
                <img src="rosehill_tpv_logo.png" alt="Rosehill TPV®" style="height: 60px;" loading="lazy">
            </picture>
            </a>
            <nav>
                <ul class="nav-menu">
                    <li><a href="index.html">Home</a></li>
                    <li><a href="products.html">Products</a></li>
                    <li><a href="applications.html">Applications</a></li>
                    <li><a href="colour.html" class="active">Colour</a></li>
                    <li><a href="installations.html">Installations</a></li>
                    <li><a href="about.html">About Us</a></li>
                    <li><a href="contact.html" class="contact-btn">Get in Touch</a></li>
                    <li class="language-switcher-desktop">
                        <a href="#" class="language-dropdown-toggle" id="language-dropdown-toggle">EN</a>
                        <div class="language-dropdown" id="language-dropdown">
                            <a href="#" class="lang-option" data-lang="en">English</a>
                            <a href="#" class="lang-option" data-lang="es">Español</a>
                            <a href="#" class="lang-option" data-lang="fr">Français</a>
                            <a href="#" class="lang-option" data-lang="de">Deutsch</a>
                        </div>
                    </li>
                </ul>
                <button class="mobile-menu-toggle" id="mobile-toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
                <div class="mobile-nav-menu" id="mobile-menu">
                    <a href="index.html">Home</a>
                    <a href="products.html">Products</a>
                    <a href="applications.html">Applications</a>
                    <a href="colour.html" class="active">Colour</a>
                    <a href="installations.html">Installations</a>
                    <a href="about.html">About Us</a>
                    <a href="contact.html" class="contact-btn">Get in Touch</a>
                </div>
            </nav>
        </div>
    </header>

    <div id="root"></div>

    <!-- Footer -->
    <footer class="footer" id="contact">
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>Contact Us</h3>
                    <p><strong>Rosehill Sports & Play</strong><br>
                    A Division of <a href="https://rosehill.group/" style="color: #ff6b35; text-decoration: none;">Rosehill Group</a><br>
                    Spring Bank Mills<br>
                    Sowerby Bridge<br>
                    West Yorkshire HX6 3BW<br>
                    United Kingdom</p>
                    <div class="footer-contact-info">
                        <div class="footer-contact-item">
                            <span class="footer-icon">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
                                    <path d="M56.71104,31.35059l-2.53662-2.53662c1.18555-1.68018,1.82959-3.69189,1.82959-5.75635,0-5.51416-4.48584-10-10-10s-10,4.48584-10,10,4.48584,10,10,10h10c.4043,0,.76904-.24365.92383-.61719.15479-.37402.06934-.8042-.2168-1.08984ZM41.00401,24.05762c-.55231,0-1-.44775-1-1,0-.55231.44769-1,1-1s1,.44769,1,1c0,.55225-.44769,1-1,1ZM46.00401,24.05762c-.55231,0-1-.44775-1-1,0-.55231.44769-1,1-1s1,.44769,1,1c0,.55225-.44769,1-1,1ZM51.00401,24.05762c-.55231,0-1-.44775-1-1,0-.55231.44769-1,1-1s1,.44769,1,1c0,.55225-.44769,1-1,1Z"/>
                                    <path d="M51.56309,45.40039l-10.17969-10.17969-1.25928-1.25928c-.39062-.39062-1.02344-.39062-1.41406,0s-.39062,1.02344,0,1.41406l.55225.55225-3.65576,3.65576c-.4126.4126-1.08301.41162-1.49463,0l-11.63379-11.63379c-.41211-.41211-.41211-1.08252,0-1.49463l3.65552-3.65552.5642.5642c.36332.36332,1.0301.38398,1.41407,0,.39062-.39062.39062-1.02344,0-1.41406,0,0-1.27014-1.2702-1.271-1.27148l-10.17981-10.17981-1.27087-1.27087c-.39062-.39062-1.02344-.39062-1.41406,0s-.39062,1.02344,0,1.41406l.56396.56396-5.10986,5.10986c-2.87549,2.875-3.24658,7.36328-.8833,10.67139,7.33447,10.26855,16.25928,19.19336,26.52734,26.52734,1.45703,1.04102,3.14209,1.55127,4.81787,1.55127,2.13037,0,4.24463-.82471,5.854-2.43408l5.10986-5.10986.55224.55224c.37609.37609,1.03944.37464,1.41407,0,.39062-.39062.39062-1.02344,0-1.41406l-1.25928-1.25928Z"/>
                                </svg>
                            </span>
                            <a href="tel:+441422839456">+44 (0)1422 839 456</a>
                        </div>
                        <div class="footer-contact-item">
                            <span class="footer-icon">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
                                    <polygon points="12 23.36124 7.69 26.95127 12 29.76127 12 23.36124"/>
                                    <path d="M32.64001,7.23124c-.37-.31-.91003-.31-1.28003,0l-3.32001,2.77002h7.92004l-3.32001-2.77002Z"/>
                                    <polygon points="52 23.36124 52 29.76127 56.31 26.95127 52 23.36124"/>
                                    <path d="M40.8385,39.4257l15.8609,15.8609c.18713-.39111.3006-.82361.3006-1.28534v-25.10992l-16.1615,10.53436Z"/>
                                    <circle cx="24" cy="50.00126" r="1"/>
                                    <path d="M8.71002,56.70127c.39996.19.82996.29999,1.28998.29999h44c.46002,0,.89001-.10999,1.28998-.29999l-23.28998-23.29004-23.28998,23.29004ZM24,53.00126c-1.65002,0-3-1.35004-3-3s1.34998-3,3-3,3,1.34998,3,3-1.34998,3-3,3ZM40,47.00126c1.65002,0,3,1.34998,3,3s-1.34998,3-3,3-3-1.35004-3-3,1.34998-3,3-3ZM35,50.00126c0,1.64996-1.34998,3-3,3s-3-1.35004-3-3,1.34998-3,3-3,3,1.34998,3,3Z"/>
                                    <circle cx="32" cy="50.00126" r="1"/>
                                    <circle cx="40" cy="50.00126" r="1"/>
                                    <path d="M7,28.89133v25.10992c0,.46173.11346.89423.3006,1.28534l15.8609-15.8609L7,28.89133Z"/>
                                    <path d="M36.44727,21.92948c.33887.16943.55273.51562.55273.89453v2.15283l4,.6665v-5.99951l-7.44238-1.48828c-1.0332-.20703-2.08105-.20703-3.11523,0l-7.44238,1.48828v5.99951l4-.6665v-2.15283c0-.37891.21387-.7251.55273-.89453,2.78516-1.3916,6.10938-1.3916,8.89453,0Z"/>
                                    <path d="M32,30.59122l7.39001,7.39001,10.60999-6.90997V13.00126c0-.54999-.45001-1-1-1H15c-.54999,0-1,.45001-1,1v18.07001l10.60999,6.90997,7.39001-7.39001ZM21.35352,27.5872c-.22412-.18994-.35352-.46924-.35352-.76318v-8c0-.47656.33643-.88721.80371-.98047l8.24609-1.64893c1.29395-.25977,2.60645-.25977,3.90039,0l8.24609,1.64893c.46729.09326.80371.50391.80371.98047v8c0,.29393-.12939.57322-.35349.76316-.22206.18821-.52433.27181-.81106.22317l-6-1c-.48193-.08008-.83545-.49756-.83545-.98633v-2.35547c-1.91602-.7793-4.08398-.7793-6,0v2.35547c0,.48877-.35352.90625-.83545.98633l-6,1c-.29004.04736-.58691-.03369-.81104-.22314Z"/>
                                </svg>
                            </span>
                            <a href="mailto:info@rosehilltpv.com">info@rosehilltpv.com</a>
                        </div>
                    </div>
                </div>
                
                <div class="footer-section">
                    <h3>Our Products</h3>
                    <ul>
                        <li><a href="products.html">Rosehill TPV<sup>®</sup> Granules</a></li>
                        <li><a href="products.html">Flexilon<sup>®</sup> Binders</a></li>
                        <li><a href="colour.html">21 Vibrant Colours</a></li>
                        <li><a href="mixer.html">Colour Mixer Tool</a></li>
                        <li><a href="contact.html">Request Samples</a></li>
                    </ul>
                </div>
                
                <div class="footer-section">
                    <h3>Applications</h3>
                    <ul>
                        <li><a href="applications.html">Sports Surfaces</a></li>
                        <li><a href="applications.html">Play Areas</a></li>
                        <li><a href="applications.html">Athletic Tracks</a></li>
                        <li><a href="applications.html">Safety Surfacing</a></li>
                        <li><a href="installations.html">View All Installations</a></li>
                    </ul>
                </div>
                
                <div class="footer-section">
                    <h3>Company</h3>
                    <ul>
                        <li><a href="about.html">About Us</a></li>
                        <li><a href="contact.html">Contact</a></li>
                        <li><a href="installations.html">Latest Installations</a></li>
                        <li><a href="colour.html">Colour Options</a></li>
                    </ul>
                    <p style="margin-top: 20px;">
                        <strong>Features:</strong><br>
                        UV Stable • Non-Toxic • 21 Colours • UK Made
                    </p>
                </div>
            </div>
            
            <div class="footer-bottom">
                <p>© 2025 Rosehill Sports & Play. A Division of <a href="https://rosehill.group/" style="color: #ff6b35; text-decoration: none;">Rosehill Group</a>. All rights reserved.</p>
            </div>
        </div>
    </footer>
    <script type="text/javascript">
        // Predefined colour palette - Rosehill TPV® colours
        const PALETTE = [
            { name: 'Beige', code: 'RH30', hex: '#E4C4AA' },
            { name: 'Cream', code: 'RH31', hex: '#E8E3D8' },
            { name: 'Bright Yellow', code: 'RH41', hex: '#FFD833' },
            { name: 'Mustard', code: 'RH40', hex: '#E5A144' },
            { name: 'Orange', code: 'RH50', hex: '#F15B32' },
            { name: 'Standard Red', code: 'RH01', hex: '#A5362F' },
            { name: 'Bright Red', code: 'RH02', hex: '#E21F2F' },
            { name: 'Funky Pink', code: 'RH90', hex: '#E8457E' },
            { name: 'Purple', code: 'RH21', hex: '#493D8C' },
            { name: 'Standard Blue', code: 'RH20', hex: '#0075BC' },
            { name: 'Light Blue', code: 'RH22', hex: '#47AFE3' },
            { name: 'Azure', code: 'RH23', hex: '#039DC4' },
            { name: 'Turquoise', code: 'RH26', hex: '#00A6A3' },
            { name: 'Dark Green', code: 'RH12', hex: '#006C55' },
            { name: 'Standard Green', code: 'RH10', hex: '#609B63' },
            { name: 'Bright Green', code: 'RH11', hex: '#3BB44A' },
            { name: 'Brown', code: 'RH32', hex: '#8B5F3C' },
            { name: 'Pale Grey', code: 'RH65', hex: '#D9D9D6' },
            { name: 'Light Grey', code: 'RH61', hex: '#939598' },
            { name: 'Dark Grey', code: 'RH60', hex: '#59595B' },
            { name: 'Black', code: 'RH70', hex: '#231F20' }
        ];

        // Wait for libraries to load
        window.addEventListener('DOMContentLoaded', function() {
            const { useState, useEffect, useRef, useCallback, useMemo } = React;

            // Simple seedable PRNG
            function mulberry32(a) {
                return function() {
                    let t = a += 0x6D2B79F5;
                    t = Math.imul(t ^ t >>> 15, t | 1);
                    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                    return ((t ^ t >>> 14) >>> 0) / 4294967296;
                };
            }

            // Poisson disk sampling
            function poissonDiskSampling(width, height, minDistance, maxTries = 30, rng = Math.random) {
                const cellSize = minDistance / Math.sqrt(2);
                const gridWidth = Math.ceil(width / cellSize);
                const gridHeight = Math.ceil(height / cellSize);
                const grid = new Array(gridWidth * gridHeight).fill(-1);
                const points = [];
                const activeList = [];

                function addPoint(x, y) {
                    const point = [x, y];
                    points.push(point);
                    const gridX = Math.floor(x / cellSize);
                    const gridY = Math.floor(y / cellSize);
                    grid[gridY * gridWidth + gridX] = points.length - 1;
                    activeList.push(points.length - 1);
                    return point;
                }

                function inNeighbourhood(x, y) {
                    const gridX = Math.floor(x / cellSize);
                    const gridY = Math.floor(y / cellSize);

                    for (let i = Math.max(0, gridX - 2); i <= Math.min(gridWidth - 1, gridX + 2); i++) {
                        for (let j = Math.max(0, gridY - 2); j <= Math.min(gridHeight - 1, gridY + 2); j++) {
                            const idx = grid[j * gridWidth + i];
                            if (idx !== -1) {
                                const dx = x - points[idx][0];
                                const dy = y - points[idx][1];
                                if (dx * dx + dy * dy < minDistance * minDistance) {
                                    return true;
                                }
                            }
                        }
                    }
                    return false;
                }

                // Add first point
                addPoint(width * rng(), height * rng());

                while (activeList.length > 0) {
                    const randomIndex = Math.floor(rng() * activeList.length);
                    const pointIndex = activeList[randomIndex];
                    const point = points[pointIndex];
                    let found = false;

                    for (let tries = 0; tries < maxTries; tries++) {
                        const angle = 2 * Math.PI * rng();
                        const radius = minDistance + minDistance * rng();
                        const x = point[0] + radius * Math.cos(angle);
                        const y = point[1] + radius * Math.sin(angle);

                        if (x >= 0 && x < width && y >= 0 && y < height && !inNeighbourhood(x, y)) {
                            addPoint(x, y);
                            found = true;
                            break;
                        }
                    }

                    if (!found) {
                        activeList.splice(randomIndex, 1);
                    }
                }

                return points;
            }

            // Generate a shareable seed
            function generateSeed() {
                return Math.random().toString(36).substring(2, 10);
            }

            // Base36 encoding/decoding for compact codes
            function encodeBase36(num) {
                return num.toString(36).toUpperCase();
            }

            function decodeBase36(str) {
                return parseInt(str, 36);
            }

            // Compress recipe data
            function compressRecipe(parts) {
                if (parts.size === 0) return '';
                return Array.from(parts.entries())
                    .map(([colourIndex, count]) => `${encodeBase36(colourIndex)}${encodeBase36(count)}`)
                    .join('');
            }

            function decompressRecipe(compressed) {
                if (!compressed) return new Map();
                const parts = new Map();
                // Parse pairs of base36 characters
                for (let i = 0; i < compressed.length; i += 2) {
                    if (i + 1 < compressed.length) {
                        const colourIndex = decodeBase36(compressed[i]);
                        const count = decodeBase36(compressed[i + 1]);
                        if (!isNaN(colourIndex) && !isNaN(count) && colourIndex >= 0 && colourIndex < PALETTE.length) {
                            parts.set(colourIndex, count);
                        }
                    }
                }
                return parts;
            }

            // 3D Tile Preview Component
            function TilePreview({ canvasRef, parts, totalParts }) {
                const tileContainerRef = useRef(null);
                const tileSceneRef = useRef(null);
                const [tileLoading, setTileLoading] = useState(false);
                const [tileError, setTileError] = useState(null);
                const [tileZoomLevel, setTileZoomLevel] = useState(1);

                // Initialize 3D scene
                useEffect(() => {
                    if (!tileContainerRef.current || typeof THREE === 'undefined') {
                        setTileError('3D not supported in this browser');
                        return;
                    }

                    // OrbitControls should now be available as we embedded it
                    if (!THREE.OrbitControls) {
                        setTileError('3D controls initialization failed');
                        return;
                    }
                    const OrbitControls = THREE.OrbitControls;

                    // Check WebGL support
                    const canvas = document.createElement('canvas');
                    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    if (!gl) {
                        setTileError('WebGL not supported in this browser');
                        return;
                    }

                    try {
                        // Scene setup
                        const scene = new THREE.Scene();
                        scene.background = new THREE.Color(0xf5f5f5);

                        // Camera setup
                        const camera = new THREE.PerspectiveCamera(
                            50,
                            tileContainerRef.current.clientWidth / tileContainerRef.current.clientHeight,
                            0.1,
                            1000
                        );
                        camera.position.set(300, 200, 300);

                        // Renderer setup with enhanced settings
                        const renderer = new THREE.WebGLRenderer({ 
                            antialias: true, 
                            alpha: true,
                            powerPreference: "high-performance"
                        });
                        renderer.setSize(
                            tileContainerRef.current.clientWidth,
                            tileContainerRef.current.clientHeight
                        );
                        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit for performance
                        renderer.shadowMap.enabled = true;
                        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                        renderer.outputEncoding = THREE.sRGBEncoding;
                        
                        // Enhanced renderer settings for better quality
                        renderer.physicallyCorrectLights = true;
                        renderer.toneMapping = THREE.ACESFilmicToneMapping;
                        renderer.toneMappingExposure = 1.2;

                        tileContainerRef.current.appendChild(renderer.domElement);

                        // Enhanced lighting setup for realistic rubber tile appearance
                        
                        // 1. Ambient light - subtle base illumination
                        const ambientLight = new THREE.AmbientLight(0xf0f8ff, 0.2); // Reduced from 0.3
                        scene.add(ambientLight);

                        // 2. Main directional light (sun-like) - creates primary shadows and highlights
                        const mainLight = new THREE.DirectionalLight(0xffffff, 0.8); // Reduced from 1.2
                        mainLight.position.set(400, 500, 300);
                        mainLight.castShadow = true;
                        mainLight.shadow.mapSize.width = 2048;
                        mainLight.shadow.mapSize.height = 2048;
                        mainLight.shadow.camera.near = 0.1;
                        mainLight.shadow.camera.far = 1000;
                        mainLight.shadow.camera.left = -300;
                        mainLight.shadow.camera.right = 300;
                        mainLight.shadow.camera.top = 300;
                        mainLight.shadow.camera.bottom = -300;
                        mainLight.shadow.bias = -0.0001;
                        scene.add(mainLight);

                        // 3. Fill light - softer light from opposite side to reduce harsh shadows
                        const fillLight = new THREE.DirectionalLight(0xf0f8ff, 0.25); // Reduced from 0.4
                        fillLight.position.set(-200, 250, -150);
                        scene.add(fillLight);

                        // 4. Rim light - creates edge highlighting for depth
                        const rimLight = new THREE.DirectionalLight(0xfff8e1, 0.35); // Reduced from 0.6
                        rimLight.position.set(-250, 200, 400);
                        scene.add(rimLight);

                        // 5. Point light for dynamic highlights on granule texture
                        const accentLight = new THREE.PointLight(0xffffff, 0.5, 800); // Reduced from 0.8
                        accentLight.position.set(150, 300, 150);
                        scene.add(accentLight);

                        // 6. Hemisphere light for natural sky/ground color variation
                        const hemiLight = new THREE.HemisphereLight(0x87ceeb, 0x8b7355, 0.15); // Reduced from 0.2
                        scene.add(hemiLight);

                        // Tile geometry (200x200x20mm - realistic size)
                        const geometry = new THREE.BoxGeometry(200, 20, 200);
                        
                        // Basic material (will be updated with texture)
                        const material = new THREE.MeshStandardMaterial({
                            color: 0xfafafa,
                            roughness: 0.8,
                            metalness: 0.1
                        });

                        const tile = new THREE.Mesh(geometry, material);
                        tile.castShadow = true;
                        tile.receiveShadow = true;
                        scene.add(tile);

                        // Ground plane for shadows
                        const groundGeometry = new THREE.PlaneGeometry(800, 800);
                        const groundMaterial = new THREE.ShadowMaterial({ opacity: 0.2 });
                        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                        ground.rotation.x = -Math.PI / 2;
                        ground.position.y = -10; // Half the tile height (20mm/2)
                        ground.receiveShadow = true;
                        scene.add(ground);

                        // Controls
                        const controls = new OrbitControls(camera, renderer.domElement);
                        controls.enableDamping = true;
                        controls.dampingFactor = 0.1;
                        controls.target.set(0, 0, 0);
                        controls.maxDistance = 800;
                        controls.minDistance = 150;

                        // Store scene references including lights for animation
                        tileSceneRef.current = {
                            scene,
                            camera,
                            renderer,
                            controls,
                            tile,
                            material,
                            lights: {
                                main: mainLight,
                                accent: accentLight,
                                rim: rimLight
                            },
                            isAnimating: true
                        };

                        // Animation loop with smart updates
                        let lastInteractionTime = Date.now();
                        let animationTime = 0;
                        let lastFrameTime = Date.now();
                        let isUserControlling = false;
                        
                        const animate = () => {
                            if (tileSceneRef.current && tileSceneRef.current.isAnimating) {
                                const now = Date.now();
                                const deltaTime = now - lastFrameTime;
                                lastFrameTime = now;
                                
                                animationTime += deltaTime * 0.001; // Convert to seconds
                                
                                // Check if user is actively controlling
                                const timeSinceInteraction = now - lastInteractionTime;
                                isUserControlling = timeSinceInteraction < 100; // 100ms threshold
                                
                                // Update controls - this now returns whether an update was applied
                                const controlsUpdated = controls.update();
                                
                                // Check if material needs updating (texture changes)
                                const materialNeedsUpdate = tileSceneRef.current.material && tileSceneRef.current.material.needsUpdate;
                                
                                let sceneChanged = controlsUpdated || materialNeedsUpdate;
                                
                                // Only apply auto-rotation if user isn't controlling and sufficient time has passed
                                if (!isUserControlling && timeSinceInteraction > 3000) { // 3 seconds of no interaction  
                                    tile.rotation.y += 0.003; // Slower rotation
                                    sceneChanged = true;
                                }
                                
                                // Always update subtle lighting animation
                                const { lights } = tileSceneRef.current;
                                
                                // Gently move the accent light in a small circle for dynamic highlights
                                lights.accent.position.x = 150 + Math.sin(animationTime * 0.4) * 25;
                                lights.accent.position.z = 150 + Math.cos(animationTime * 0.4) * 25;
                                
                                // Subtle intensity variation for more natural look
                                lights.accent.intensity = 0.5 + Math.sin(animationTime * 0.25) * 0.06;
                                lights.rim.intensity = 0.35 + Math.cos(animationTime * 0.3) * 0.03;
                                
                                // Only render if something changed
                                if (sceneChanged) {
                                    renderer.render(scene, camera);
                                }
                                
                                requestAnimationFrame(animate);
                            }
                        };
                        
                        // Track user interactions to pause auto-rotation
                        const updateInteractionTime = () => { lastInteractionTime = Date.now(); };
                        renderer.domElement.addEventListener('mousedown', updateInteractionTime);
                        renderer.domElement.addEventListener('touchstart', updateInteractionTime);
                        renderer.domElement.addEventListener('wheel', updateInteractionTime);
                        animate();

                        // Handle resize
                        const handleResize = () => {
                            if (tileContainerRef.current && tileSceneRef.current) {
                                const width = tileContainerRef.current.clientWidth;
                                const height = tileContainerRef.current.clientHeight;
                                
                                camera.aspect = width / height;
                                camera.updateProjectionMatrix();
                                renderer.setSize(width, height);
                            }
                        };

                        window.addEventListener('resize', handleResize);

                        return () => {
                            window.removeEventListener('resize', handleResize);
                            if (tileSceneRef.current) {
                                tileSceneRef.current.isAnimating = false;
                                if (tileContainerRef.current && renderer.domElement) {
                                    tileContainerRef.current.removeChild(renderer.domElement);
                                }
                                renderer.dispose();
                                geometry.dispose();
                                material.dispose();
                                controls.dispose();
                            }
                        };

                    } catch (error) {
                        console.error('3D initialization error:', error);
                        setTileError('Failed to initialize 3D preview');
                    }
                }, []);

                // Create randomized texture from canvas
                const createRandomizedTexture = useCallback((sourceCanvas) => {
                    if (!sourceCanvas) return null;

                    // Create a larger canvas for randomized tiling
                    const randomCanvas = document.createElement('canvas');
                    const randomCtx = randomCanvas.getContext('2d');
                    const tileSize = 512; // Higher resolution for better quality
                    randomCanvas.width = tileSize;
                    randomCanvas.height = tileSize;

                    // Number of random tiles to create variation
                    const tilesPerRow = 4;
                    const tileWidth = tileSize / tilesPerRow;
                    const tileHeight = tileSize / tilesPerRow;

                    // Create random placement of source texture
                    for (let x = 0; x < tilesPerRow; x++) {
                        for (let y = 0; y < tilesPerRow; y++) {
                            const destX = x * tileWidth;
                            const destY = y * tileHeight;
                            
                            // Random rotation and flip for variation
                            randomCtx.save();
                            randomCtx.translate(destX + tileWidth/2, destY + tileHeight/2);
                            
                            // Random rotation (0, 90, 180, or 270 degrees)
                            const rotation = (Math.floor(Math.random() * 4) * Math.PI) / 2;
                            randomCtx.rotate(rotation);
                            
                            // Random flip
                            const flipX = Math.random() > 0.5 ? -1 : 1;
                            const flipY = Math.random() > 0.5 ? -1 : 1;
                            randomCtx.scale(flipX, flipY);
                            
                            // Random offset within the source canvas
                            const sourceSize = Math.min(sourceCanvas.width, sourceCanvas.height);
                            const offsetX = Math.random() * (sourceCanvas.width - sourceSize);
                            const offsetY = Math.random() * (sourceCanvas.height - sourceSize);
                            
                            randomCtx.drawImage(
                                sourceCanvas,
                                offsetX, offsetY, sourceSize, sourceSize,
                                -tileWidth/2, -tileHeight/2, tileWidth, tileHeight
                            );
                            randomCtx.restore();
                        }
                    }

                    return randomCanvas;
                }, []);

                // Create bump map for surface texture
                const createBumpMap = useCallback(() => {
                    const bumpCanvas = document.createElement('canvas');
                    const bumpCtx = bumpCanvas.getContext('2d');
                    const size = 256;
                    bumpCanvas.width = size;
                    bumpCanvas.height = size;

                    // Create noise pattern for bump map
                    const imageData = bumpCtx.createImageData(size, size);
                    const data = imageData.data;

                    for (let i = 0; i < data.length; i += 4) {
                        // Generate noise with different frequencies for realistic granule texture
                        const x = (i / 4) % size;
                        const y = Math.floor((i / 4) / size);
                        
                        // Multiple octaves of noise for complex surface
                        let noise = 0;
                        noise += Math.sin(x * 0.1) * Math.cos(y * 0.1) * 0.3;
                        noise += Math.sin(x * 0.05) * Math.cos(y * 0.05) * 0.5;
                        noise += Math.random() * 0.2; // Fine detail
                        
                        // Convert to grayscale value (0-255)
                        const value = Math.floor((noise + 1) * 127.5);
                        
                        data[i] = value;     // Red
                        data[i + 1] = value; // Green
                        data[i + 2] = value; // Blue
                        data[i + 3] = 255;   // Alpha
                    }

                    bumpCtx.putImageData(imageData, 0, 0);
                    return bumpCanvas;
                }, []);

                // Update tile texture when canvas changes
                useEffect(() => {
                    if (!tileSceneRef.current || !canvasRef.current || totalParts === 0) {
                        // Reset to default material when no parts
                        if (tileSceneRef.current) {
                            const { material, controls } = tileSceneRef.current;
                            material.map = null;
                            material.bumpMap = null;
                            material.normalMap = null;
                            material.color.setHex(0xfafafa);
                            material.needsUpdate = true;
                            
                            // Force a render update
                            if (controls) {
                                controls.update();
                            }
                        }
                        return;
                    }

                    setTileLoading(true);

                    // Small delay to ensure canvas is updated
                    setTimeout(() => {
                        try {
                            // Create randomized texture
                            const randomizedCanvas = createRandomizedTexture(canvasRef.current);
                            if (!randomizedCanvas) {
                                setTileLoading(false);
                                return;
                            }

                            // Create main texture
                            const texture = new THREE.CanvasTexture(randomizedCanvas);
                            texture.wrapS = THREE.RepeatWrapping;
                            texture.wrapT = THREE.RepeatWrapping;
                            texture.repeat.set(2, 2); // Less obvious tiling
                            texture.magFilter = THREE.LinearFilter;
                            texture.minFilter = THREE.LinearMipMapLinearFilter;

                            // Create bump map for surface detail
                            const bumpCanvas = createBumpMap();
                            const bumpTexture = new THREE.CanvasTexture(bumpCanvas);
                            bumpTexture.wrapS = THREE.RepeatWrapping;
                            bumpTexture.wrapT = THREE.RepeatWrapping;
                            bumpTexture.repeat.set(8, 8); // Higher frequency for fine detail

                            // Update material with enhanced properties
                            const { material } = tileSceneRef.current;
                            material.map = texture;
                            material.bumpMap = bumpTexture;
                            material.bumpScale = 0.05; // More pronounced bump for larger, realistic granules
                            material.roughness = 0.9; // More rubber-like
                            material.metalness = 0.05; // Very low metalness for rubber
                            material.color.setHex(0xffffff);
                            material.needsUpdate = true;

                            // Force a render update since texture has changed
                            if (tileSceneRef.current.controls) {
                                tileSceneRef.current.controls.update();
                            }

                            setTileLoading(false);
                        } catch (error) {
                            console.error('Texture update error:', error);
                            setTileLoading(false);
                        }
                    }, 100);
                }, [totalParts, parts, createRandomizedTexture, createBumpMap]);

                const resetTileView = useCallback(() => {
                    if (tileSceneRef.current) {
                        const { camera, controls, tile } = tileSceneRef.current;
                        camera.position.set(300, 200, 300);
                        tile.rotation.set(0, 0, 0);
                        controls.reset();
                        controls.update(); // Ensure rendering happens
                        setTileZoomLevel(1); // Reset zoom level state
                    }
                }, []);

                // 3D Tile Zoom Functions
                const zoomIn3D = useCallback(() => {
                    if (tileSceneRef.current) {
                        const { controls } = tileSceneRef.current;
                        const zoomFactor = 0.8; // Stronger zoom than mouse wheel
                        
                        // Apply zoom by scaling
                        if (controls.camera.position.length() * zoomFactor > 50) { // Minimum distance
                            controls.camera.position.multiplyScalar(zoomFactor);
                            setTileZoomLevel(prev => Math.min(prev / zoomFactor, 4)); // Max 4x zoom
                            controls.update();
                        }
                    }
                }, []);

                const zoomOut3D = useCallback(() => {
                    if (tileSceneRef.current) {
                        const { controls } = tileSceneRef.current;
                        const zoomFactor = 1.25; // Inverse of zoom in
                        
                        // Apply zoom by scaling
                        if (controls.camera.position.length() * zoomFactor < 800) { // Maximum distance
                            controls.camera.position.multiplyScalar(zoomFactor);
                            setTileZoomLevel(prev => Math.max(prev / zoomFactor, 0.25)); // Min 0.25x zoom
                            controls.update();
                        }
                    }
                }, []);

                const resetZoom3D = useCallback(() => {
                    if (tileSceneRef.current) {
                        const { camera, controls } = tileSceneRef.current;
                        camera.position.set(300, 200, 300); // Reset to default position
                        setTileZoomLevel(1);
                        controls.update();
                    }
                }, []);

                // Double-tap zoom functionality
                const lastTapRef = useRef(0);
                const handleDoubleTap = useCallback((event) => {
                    const now = Date.now();
                    const timeSince = now - lastTapRef.current;
                    
                    if (timeSince < 300 && timeSince > 0) {
                        // Double tap detected
                        event.preventDefault();
                        zoomIn3D();
                    }
                    
                    lastTapRef.current = now;
                }, [zoomIn3D]);

                // Add double-click for desktop
                const handleDoubleClick = useCallback((event) => {
                    event.preventDefault();
                    zoomIn3D();
                }, [zoomIn3D]);

                return React.createElement('div', { className: 'tile-preview-section' },
                    React.createElement('h2', { className: 'palette-title' }, '3D Tile Preview'),
                    React.createElement('div', { 
                        className: 'tile-preview-container',
                        ref: tileContainerRef,
                        style: { position: 'relative' },
                        onTouchEnd: handleDoubleTap,
                        onDoubleClick: handleDoubleClick
                    },
                        tileLoading && React.createElement('div', { className: 'tile-preview-loading' }, 'Updating texture...'),
                        tileError && React.createElement('div', { className: 'tile-preview-error' }, tileError),
                        !tileError && React.createElement('div', { className: 'tile-zoom-controls' },
                            React.createElement('button', {
                                className: 'tile-zoom-btn',
                                onClick: zoomIn3D,
                                disabled: tileZoomLevel >= 4,
                                title: 'Zoom In',
                                'aria-label': 'Zoom In 3D Tile'
                            }, '+'),
                            React.createElement('button', {
                                className: 'tile-zoom-btn',
                                onClick: zoomOut3D,
                                disabled: tileZoomLevel <= 0.25,
                                title: 'Zoom Out',
                                'aria-label': 'Zoom Out 3D Tile'
                            }, '−'),
                            React.createElement('button', {
                                className: 'tile-zoom-btn',
                                onClick: resetZoom3D,
                                title: 'Reset Zoom',
                                'aria-label': 'Reset 3D Tile Zoom',
                                style: { fontSize: '14px' }
                            }, '↻')
                        )
                    ),
                    React.createElement('div', { className: 'tile-preview-controls' },
                        React.createElement('div', { className: 'tile-preview-info' },
                            React.createElement('span', null, '200×200×20mm tile • 1-4mm granules')
                        ),
                        React.createElement('button', {
                            className: 'tile-preview-reset',
                            onClick: resetTileView
                        }, 'Reset View')
                    )
                );
            }

            // Main App Component
            function App() {
                const canvasRef = useRef(null);
                const [isInitializing, setIsInitializing] = useState(true);
                const [parts, setParts] = useState(new Map());
                const [seed, setSeed] = useState(generateSeed());
                const [undoStack, setUndoStack] = useState([]);
                const [redoStack, setRedoStack] = useState([]);
                const [voronoiData, setVoronoiData] = useState(null);
                const [tooltip, setTooltip] = useState(null);
                const [zoomLevel, setZoomLevel] = useState(2);
                const [panOffset, setPanOffset] = useState({ x: 0, y: 0 });
                const [isPanning, setIsPanning] = useState(false);
                const [lastMousePos, setLastMousePos] = useState({ x: 0, y: 0 });
                const [projectDetails, setProjectDetails] = useState({
                    name: '',
                    location: '',
                    area: '',
                    depth: '',
                    notes: ''
                });
                const [shareInput, setShareInput] = useState('');
                const [shareError, setShareError] = useState('');

                const canvasWidth = 1000;
                const canvasHeight = 500;
                const exportWidth = 2000;
                const exportHeight = 1000;

                // Initialize Voronoi diagram
                useEffect(() => {
                    const initializeVoronoi = async () => {
                        setIsInitializing(true);
                        
                        // Generate points using seeded RNG
                        const seedNum = seed.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
                        const rng = mulberry32(seedNum);
                        
                        // Adjust minDistance for desired cell count (~50,000 cells)
                        const targetCells = 50000;
                        const area = canvasWidth * canvasHeight;
                        const minDistance = Math.sqrt(area / targetCells) * 2;
                        
                        const points = poissonDiskSampling(canvasWidth, canvasHeight, minDistance, 30, rng);
                        
                        // Add enhanced size variation to points
                        const pointsWithSize = points.map(([x, y]) => ({
                            x,
                            y,
                            size: 0.6 + rng() * 0.8 // 60% to 140% size variation
                        }));
                        
                        // Create Voronoi diagram
                        const delaunay = d3.Delaunay.from(pointsWithSize, p => p.x, p => p.y);
                        const voronoi = delaunay.voronoi([0, 0, canvasWidth, canvasHeight]);
                        
                        setVoronoiData({
                            points: pointsWithSize,
                            voronoi,
                            delaunay,
                            cells: Array.from({ length: points.length }, (_, i) => ({
                                index: i,
                                colourIndex: -1,
                                polygon: [...voronoi.cellPolygon(i)]
                            }))
                        });
                        
                        setIsInitializing(false);
                    };

                    initializeVoronoi();
                }, [seed]);

                // Render canvas
                useEffect(() => {
                    if (!voronoiData || !canvasRef.current) return;

                    const canvas = canvasRef.current;
                    const ctx = canvas.getContext('2d');
                    canvas.width = canvasWidth;
                    canvas.height = canvasHeight;
                    
                    // Save the current state
                    ctx.save();
                    
                    // Apply zoom and pan transformations
                    ctx.translate(panOffset.x, panOffset.y);
                    ctx.scale(zoomLevel, zoomLevel);

                    // Clear canvas with light grey background
                    ctx.fillStyle = '#FAFAFA';
                    ctx.fillRect(0, 0, canvasWidth, canvasHeight);

                    // Calculate colour distribution
                    const totalParts = Array.from(parts.values()).reduce((a, b) => a + b, 0);
                    const cellAssignments = new Array(voronoiData.cells.length).fill(-1);
                    
                    if (totalParts > 0) {
                        // Create shuffled indices using seed
                        const seedNum = (seed + totalParts).split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
                        const rng = mulberry32(seedNum);
                        const indices = Array.from({ length: voronoiData.cells.length }, (_, i) => i);
                        
                        // Fisher-Yates shuffle
                        for (let i = indices.length - 1; i > 0; i--) {
                            const j = Math.floor(rng() * (i + 1));
                            [indices[i], indices[j]] = [indices[j], indices[i]];
                        }

                        // Assign colours based on parts
                        let cursor = 0;
                        parts.forEach((partCount, colourIndex) => {
                            const quota = Math.round((partCount / totalParts) * indices.length);
                            for (let i = 0; i < quota && cursor < indices.length; i++) {
                                cellAssignments[indices[cursor]] = colourIndex;
                                cursor++;
                            }
                        });
                    } else {
                        // If no parts selected, show white granules (no color assigned)
                        for (let i = 0; i < cellAssignments.length; i++) {
                            cellAssignments[i] = -1; // No color assigned (white)
                        }
                    }

                    // First pass: Draw all cells without strokes to ensure complete coverage
                    voronoiData.cells.forEach((cell, i) => {
                        const polygon = cell.polygon;
                        if (!polygon || polygon.length < 3) return;

                        const colourIndex = cellAssignments[i];
                        const colour = colourIndex === -1 ? { hex: '#FAFAFA' } : PALETTE[colourIndex];
                        
                        // Draw cell with solid color first
                        ctx.beginPath();
                        ctx.moveTo(polygon[0][0], polygon[0][1]);
                        for (let j = 1; j < polygon.length; j++) {
                            ctx.lineTo(polygon[j][0], polygon[j][1]);
                        }
                        ctx.closePath();
                        
                        ctx.fillStyle = colour.hex;
                        ctx.fill();
                    });

                    // Second pass: Add 3D effects only for colored cells
                    voronoiData.cells.forEach((cell, i) => {
                        const colourIndex = cellAssignments[i];
                        if (colourIndex === -1) return; // Skip unassigned cells (white)
                        
                        const polygon = cell.polygon;
                        if (!polygon || polygon.length < 3) return;

                        const colour = PALETTE[colourIndex];
                        
                        // Calculate cell center
                        let centerX = 0, centerY = 0;
                        for (let j = 0; j < polygon.length; j++) {
                            centerX += polygon[j][0];
                            centerY += polygon[j][1];
                        }
                        centerX /= polygon.length;
                        centerY /= polygon.length;

                        // Create edge-based shading for realistic 3D effect
                        const granuleSize = voronoiData.points[i].size || 1;
                        
                        // Light direction vector (from top-left)
                        const lightDir = { x: -0.7071, y: -0.7071 }; // Normalized diagonal direction
                        
                        // Calculate polygon lighting zones based on edge orientations
                        let totalLighting = 0;
                        let lightedArea = 0;
                        
                        for (let j = 0; j < polygon.length; j++) {
                            const p1 = polygon[j];
                            const p2 = polygon[(j + 1) % polygon.length];
                            
                            // Calculate edge vector and normal
                            const edgeVec = { x: p2[0] - p1[0], y: p2[1] - p1[1] };
                            const edgeLength = Math.sqrt(edgeVec.x * edgeVec.x + edgeVec.y * edgeVec.y);
                            
                            // Skip degenerate edges (zero length)
                            if (edgeLength < 0.001) continue;
                            
                            // Calculate edge normal (perpendicular, pointing inward)
                            const normal = { 
                                x: -edgeVec.y / edgeLength, 
                                y: edgeVec.x / edgeLength 
                            };
                            
                            // Calculate lighting intensity based on edge normal vs light direction
                            const lightIntensity = Math.max(0, -(normal.x * lightDir.x + normal.y * lightDir.y));
                            
                            totalLighting += lightIntensity * edgeLength;
                            lightedArea += edgeLength;
                        }
                        
                        // Calculate average lighting for this polygon with fallback
                        const avgLighting = lightedArea > 0 ? totalLighting / lightedArea : 0.5;
                        
                        // Scale lighting effect by granule size for variation
                        const sizeFactor = 0.7 + Math.max(0, Math.min(0.8, granuleSize - 0.6)) / 0.8 * 0.6; // Scale 0.7-1.3 based on size
                        const lightingIntensity = Math.min(1, Math.max(0, avgLighting * sizeFactor));
                        
                        // Calculate bounds for gradient positioning
                        let minX = polygon[0][0], maxX = polygon[0][0];
                        let minY = polygon[0][1], maxY = polygon[0][1];
                        for (let j = 1; j < polygon.length; j++) {
                            minX = Math.min(minX, polygon[j][0]);
                            maxX = Math.max(maxX, polygon[j][0]);
                            minY = Math.min(minY, polygon[j][1]);
                            maxY = Math.max(maxY, polygon[j][1]);
                        }
                        
                        // Ensure valid gradient coordinates
                        const gradientOffset = Math.max(1, (maxX - minX) * (0.2 + lightingIntensity * 0.3));
                        const gradientOffsetY = Math.max(1, (maxY - minY) * (0.2 + lightingIntensity * 0.3));
                        
                        // Create gradient based on edge lighting analysis with validation
                        const gradient = ctx.createLinearGradient(
                            minX + gradientOffset,
                            minY + gradientOffsetY,
                            maxX - gradientOffset,
                            maxY - gradientOffsetY
                        );
                        
                        // Parse hex colour
                        const r = parseInt(colour.hex.slice(1, 3), 16);
                        const g = parseInt(colour.hex.slice(3, 5), 16);
                        const b = parseInt(colour.hex.slice(5, 7), 16);
                        
                        // Add gradient stops based on edge lighting analysis with validation
                        const highlightStrength = Math.floor(Math.max(0, Math.min(20, lightingIntensity * 20))); // 0-20 intensity
                        const shadowStrength = Math.floor(Math.max(0, Math.min(25, (1 - lightingIntensity) * 25))); // 0-25 intensity
                        
                        gradient.addColorStop(0, `rgba(${Math.min(255, Math.max(0, r + highlightStrength))}, ${Math.min(255, Math.max(0, g + highlightStrength))}, ${Math.min(255, Math.max(0, b + highlightStrength))}, 1)`);
                        gradient.addColorStop(0.2, `rgba(${Math.min(255, Math.max(0, r + highlightStrength * 0.4))}, ${Math.min(255, Math.max(0, g + highlightStrength * 0.4))}, ${Math.min(255, Math.max(0, b + highlightStrength * 0.4))}, 1)`);
                        gradient.addColorStop(0.5, colour.hex);
                        gradient.addColorStop(0.7, `rgba(${Math.max(0, Math.min(255, r - shadowStrength * 0.4))}, ${Math.max(0, Math.min(255, g - shadowStrength * 0.4))}, ${Math.max(0, Math.min(255, b - shadowStrength * 0.4))}, 1)`);
                        gradient.addColorStop(1, `rgba(${Math.max(0, Math.min(255, r - shadowStrength))}, ${Math.max(0, Math.min(255, g - shadowStrength))}, ${Math.max(0, Math.min(255, b - shadowStrength))}, 1)`);

                        // Draw cell with gradient
                        ctx.beginPath();
                        ctx.moveTo(polygon[0][0], polygon[0][1]);
                        for (let j = 1; j < polygon.length; j++) {
                            ctx.lineTo(polygon[j][0], polygon[j][1]);
                        }
                        ctx.closePath();
                        
                        ctx.fillStyle = gradient;
                        ctx.fill();
                    });
                    
                    // Add instructional text for blank canvas
                    if (totalParts === 0) {
                        ctx.save();
                        ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transformations for text
                        ctx.fillStyle = '#999999';
                        ctx.font = '24px "Source Sans Pro", sans-serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('Click colours below to add granules', canvasWidth / 2, canvasHeight / 2);
                        ctx.restore();
                    }
                    
                    // Restore the canvas state
                    ctx.restore();
                }, [voronoiData, parts, seed, zoomLevel, panOffset]);

                // Add part function
                const addPart = useCallback((colourIndex) => {
                    setUndoStack(prev => [...prev, new Map(parts)]);
                    setRedoStack([]);
                    setParts(prev => {
                        const newParts = new Map(prev);
                        newParts.set(colourIndex, (newParts.get(colourIndex) || 0) + 1);
                        return newParts;
                    });
                }, [parts]);

                // Remove part function
                const removePart = useCallback((colourIndex) => {
                    const currentParts = parts.get(colourIndex) || 0;
                    if (currentParts > 0) {
                        setUndoStack(prev => [...prev, new Map(parts)]);
                        setRedoStack([]);
                        setParts(prev => {
                            const newParts = new Map(prev);
                            if (currentParts === 1) {
                                newParts.delete(colourIndex);
                            } else {
                                newParts.set(colourIndex, currentParts - 1);
                            }
                            return newParts;
                        });
                    }
                }, [parts]);

                // Undo/Redo functions
                const undo = useCallback(() => {
                    if (undoStack.length === 0) return;
                    const newUndoStack = [...undoStack];
                    const previousState = newUndoStack.pop();
                    setUndoStack(newUndoStack);
                    setRedoStack(prev => [...prev, new Map(parts)]);
                    setParts(previousState);
                }, [undoStack, parts]);

                const redo = useCallback(() => {
                    if (redoStack.length === 0) return;
                    const newRedoStack = [...redoStack];
                    const nextState = newRedoStack.pop();
                    setRedoStack(newRedoStack);
                    setUndoStack(prev => [...prev, new Map(parts)]);
                    setParts(nextState);
                }, [redoStack, parts]);

                // Clear function
                const clear = useCallback(() => {
                    setUndoStack(prev => [...prev, new Map(parts)]);
                    setRedoStack([]);
                    setParts(new Map());
                }, [parts]);

                // Export function
                const exportPNG = useCallback(() => {
                    const exportCanvas = document.createElement('canvas');
                    exportCanvas.width = exportWidth;
                    exportCanvas.height = exportHeight;
                    const ctx = exportCanvas.getContext('2d');
                    
                    // Scale and draw current canvas to export canvas
                    ctx.drawImage(canvasRef.current, 0, 0, canvasWidth, canvasHeight, 0, 0, exportWidth, exportHeight);
                    
                    exportCanvas.toBlob((blob) => {
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `granule-mix-${seed}.png`;
                        a.click();
                        URL.revokeObjectURL(url);
                    });
                }, [seed]);

                // Calculate percentages and blend color
                const totalParts = Array.from(parts.values()).reduce((a, b) => a + b, 0);
                const percentages = new Map();
                parts.forEach((count, colourIndex) => {
                    percentages.set(colourIndex, (count / totalParts) * 100);
                });

                // Calculate blended color
                const calculateBlendedColor = useCallback(() => {
                    if (totalParts === 0) return '#FFFFFF';
                    
                    let totalR = 0, totalG = 0, totalB = 0;
                    
                    parts.forEach((count, colourIndex) => {
                        const colour = PALETTE[colourIndex];
                        const weight = count / totalParts;
                        
                        // Parse hex color
                        const r = parseInt(colour.hex.slice(1, 3), 16);
                        const g = parseInt(colour.hex.slice(3, 5), 16);
                        const b = parseInt(colour.hex.slice(5, 7), 16);
                        
                        totalR += r * weight;
                        totalG += g * weight;
                        totalB += b * weight;
                    });
                    
                    // Convert back to hex
                    const toHex = (n) => {
                        const hex = Math.round(Math.max(0, Math.min(255, n))).toString(16);
                        return hex.length === 1 ? '0' + hex : hex;
                    };
                    
                    return '#' + toHex(totalR) + toHex(totalG) + toHex(totalB);
                }, [parts, totalParts]);

                const blendedColor = calculateBlendedColor();
                const blendedRgb = blendedColor !== '#FFFFFF' ? {
                    r: parseInt(blendedColor.slice(1, 3), 16),
                    g: parseInt(blendedColor.slice(3, 5), 16),
                    b: parseInt(blendedColor.slice(5, 7), 16)
                } : { r: 255, g: 255, b: 255 };

                // Get contrast color for text
                const getContrastColor = (hex) => {
                    const r = parseInt(hex.slice(1, 3), 16);
                    const g = parseInt(hex.slice(3, 5), 16);
                    const b = parseInt(hex.slice(5, 7), 16);
                    const brightness = (r * 299 + g * 587 + b * 114) / 1000;
                    return brightness > 128 ? '#000000' : '#FFFFFF';
                };

                // Generate compact share code
                const shareCode = useMemo(() => {
                    const compressedRecipe = compressRecipe(parts);
                    return `${seed.toUpperCase()}${compressedRecipe}`;
                }, [seed, parts]);

                // Copy to clipboard
                const copyShareCode = useCallback(() => {
                    navigator.clipboard.writeText(shareCode);
                    setTooltip({ text: 'Copied!', x: window.innerWidth / 2, y: 100 });
                    setTimeout(() => setTooltip(null), 2000);
                }, [shareCode]);

                // Load share code
                const loadShareCode = useCallback(() => {
                    setShareError('');
                    
                    if (!shareInput.trim()) {
                        setShareError('Please enter a share code');
                        return;
                    }
                    
                    const code = shareInput.trim().toUpperCase();
                    
                    // Validate minimum length (8 char seed + at least 2 char recipe)
                    if (code.length < 8) {
                        setShareError('Invalid share code format');
                        return;
                    }
                    
                    try {
                        const seedPart = code.substring(0, 8).toLowerCase();
                        const recipePart = code.substring(8);
                        
                        const newParts = decompressRecipe(recipePart);
                        
                        // Save current state to undo stack
                        setUndoStack(prev => [...prev, new Map(parts)]);
                        setRedoStack([]);
                        
                        // Load new state
                        setSeed(seedPart);
                        setParts(newParts);
                        setShareInput('');
                        
                        setTooltip({ text: 'Mix loaded!', x: window.innerWidth / 2, y: 100 });
                        setTimeout(() => setTooltip(null), 2000);
                        
                    } catch (error) {
                        setShareError('Invalid share code format');
                    }
                }, [shareInput, parts]);

                // Helper function to constrain pan offset within bounds
                const constrainPanOffset = useCallback((offset, zoom) => {
                    const maxPanX = Math.max(0, (canvasWidth * zoom - canvasWidth) / 2);
                    const maxPanY = Math.max(0, (canvasHeight * zoom - canvasHeight) / 2);
                    
                    return {
                        x: Math.max(-maxPanX, Math.min(maxPanX, offset.x)),
                        y: Math.max(-maxPanY, Math.min(maxPanY, offset.y))
                    };
                }, []);

                // Zoom functions
                const zoomIn = useCallback(() => {
                    setZoomLevel(prev => {
                        const newZoom = Math.min(prev * 1.2, 5);
                        // Constrain pan offset for new zoom level
                        setPanOffset(currentOffset => constrainPanOffset(currentOffset, newZoom));
                        return newZoom;
                    });
                }, [constrainPanOffset]);

                const zoomOut = useCallback(() => {
                    setZoomLevel(prev => {
                        const newZoom = Math.max(prev / 1.2, 0.5);
                        // Constrain pan offset for new zoom level
                        setPanOffset(currentOffset => constrainPanOffset(currentOffset, newZoom));
                        return newZoom;
                    });
                }, [constrainPanOffset]);

                const resetCanvas = useCallback(() => {
                    // Clear all parts
                    setUndoStack(prev => [...prev, new Map(parts)]);
                    setRedoStack([]);
                    setParts(new Map());
                    // Reset zoom and pan
                    setZoomLevel(2);
                    setPanOffset({ x: 0, y: 0 });
                }, [parts]);

                // Calculate material requirements
                const calculateMaterial = useCallback((area, depth) => {
                    const areaNum = parseFloat(area);
                    const depthNum = parseFloat(depth);
                    if (isNaN(areaNum) || isNaN(depthNum) || areaNum <= 0 || depthNum <= 0) {
                        return 0;
                    }
                    
                    // Material density lookup table based on real installation data
                    const materialDensity = {
                        10: 9.0,    // 9kg/m² at 10mm depth
                        15: 14.5,   // 14.5kg/m² at 15mm depth
                        20: 18.0,   // 18kg/m² at 20mm depth
                        25: 23.5    // 23.5kg/m² at 25mm depth
                    };
                    
                    // Get density for exact depths or interpolate for custom depths
                    let densityPerM2;
                    if (materialDensity[depthNum]) {
                        densityPerM2 = materialDensity[depthNum];
                    } else {
                        // Linear interpolation for custom depths
                        const depths = Object.keys(materialDensity).map(Number).sort((a, b) => a - b);
                        
                        if (depthNum < depths[0]) {
                            // Extrapolate below minimum (use 10mm ratio)
                            densityPerM2 = (depthNum / 10) * materialDensity[10];
                        } else if (depthNum > depths[depths.length - 1]) {
                            // Extrapolate above maximum (use 25mm ratio)
                            densityPerM2 = (depthNum / 25) * materialDensity[25];
                        } else {
                            // Interpolate between known values
                            let lowerDepth = depths[0];
                            let upperDepth = depths[depths.length - 1];
                            
                            for (let i = 0; i < depths.length - 1; i++) {
                                if (depthNum >= depths[i] && depthNum <= depths[i + 1]) {
                                    lowerDepth = depths[i];
                                    upperDepth = depths[i + 1];
                                    break;
                                }
                            }
                            
                            const ratio = (depthNum - lowerDepth) / (upperDepth - lowerDepth);
                            densityPerM2 = materialDensity[lowerDepth] + 
                                          (materialDensity[upperDepth] - materialDensity[lowerDepth]) * ratio;
                        }
                    }
                    
                    return Math.round(areaNum * densityPerM2);
                }, []);

                const materialRequired = calculateMaterial(projectDetails.area, projectDetails.depth);

                // Calculate individual color material requirements
                const calculateColorMaterials = useCallback(() => {
                    if (totalParts === 0 || materialRequired === 0) return [];
                    
                    return Array.from(parts.entries()).map(([colorIndex, count]) => {
                        const color = PALETTE[colorIndex];
                        const percentage = (count / totalParts) * 100;
                        const quantity = Math.round((percentage / 100) * materialRequired);
                        
                        return {
                            colorIndex,
                            name: color.name,
                            code: color.code,
                            hex: color.hex,
                            percentage: Math.round(percentage),
                            quantity,
                            parts: count
                        };
                    }).sort((a, b) => b.quantity - a.quantity); // Sort by quantity descending
                }, [parts, totalParts, materialRequired]);

                const colorMaterials = calculateColorMaterials();

                // Generate PDF
                const generatePDF = useCallback(() => {
                    const { jsPDF } = window.jspdf;
                    const doc = new jsPDF();
                    
                    // Helper function to draw color swatch
                    const drawColorSwatch = (x, y, width, height, hexColor) => {
                        const r = parseInt(hexColor.slice(1, 3), 16);
                        const g = parseInt(hexColor.slice(3, 5), 16);
                        const b = parseInt(hexColor.slice(5, 7), 16);
                        doc.setFillColor(r, g, b);
                        doc.rect(x, y, width, height, 'F');
                        doc.setDrawColor(0, 0, 0);
                        doc.setLineWidth(0.1);
                        doc.rect(x, y, width, height, 'S');
                    };
                    
                    // Header with branding
                    doc.setFillColor(26, 54, 93); // Dark blue background
                    doc.rect(0, 0, 210, 35, 'F');
                    
                    doc.setTextColor(255, 255, 255);
                    doc.setFont('helvetica', 'normal');
                    doc.setFontSize(24);
                    doc.text('Rosehill TPV®', 20, 20);
                    
                    doc.setFont('helvetica', 'bold');
                    doc.setFontSize(18);
                    doc.text('Colour Mixer Report', 20, 30);
                    
                    // Orange accent stripe
                    doc.setFillColor(241, 91, 50);
                    doc.rect(0, 35, 210, 3, 'F');
                    
                    // Reset text color
                    doc.setTextColor(0, 0, 0);
                    let yPos = 55;
                    
                    // Project Details Section
                    doc.setFont('helvetica', 'bold');
                    doc.setFontSize(16);
                    doc.text('Project Details', 20, yPos);
                    yPos += 5;
                    
                    // Calculate the height needed for project details box
                    let projectDetailsHeight = 10; // Base padding
                    if (projectDetails.name) projectDetailsHeight += 8;
                    if (projectDetails.location) projectDetailsHeight += 8;
                    if (projectDetails.area) projectDetailsHeight += 8;
                    if (projectDetails.depth) projectDetailsHeight += 8;
                    projectDetailsHeight += 5; // Bottom padding
                    
                    // Light grey background for project details
                    doc.setFillColor(248, 249, 250);
                    doc.rect(20, yPos, 170, projectDetailsHeight, 'F');
                    doc.setDrawColor(233, 236, 239);
                    doc.setLineWidth(0.5);
                    doc.rect(20, yPos, 170, projectDetailsHeight, 'S');
                    
                    yPos += 10;
                    doc.setFont('helvetica', 'normal');
                    doc.setFontSize(11);
                    
                    if (projectDetails.name) {
                        doc.setFont('helvetica', 'bold');
                        doc.text('Project Name:', 25, yPos);
                        doc.setFont('helvetica', 'normal');
                        doc.text(projectDetails.name, 70, yPos);
                        yPos += 8;
                    }
                    if (projectDetails.location) {
                        doc.setFont('helvetica', 'bold');
                        doc.text('Location:', 25, yPos);
                        doc.setFont('helvetica', 'normal');
                        doc.text(projectDetails.location, 70, yPos);
                        yPos += 8;
                    }
                    if (projectDetails.area) {
                        doc.setFont('helvetica', 'bold');
                        doc.text('Area:', 25, yPos);
                        doc.setFont('helvetica', 'normal');
                        doc.text(`${projectDetails.area} m²`, 70, yPos);
                        yPos += 8;
                    }
                    if (projectDetails.depth) {
                        doc.setFont('helvetica', 'bold');
                        doc.text('Depth:', 25, yPos);
                        doc.setFont('helvetica', 'normal');
                        doc.text(`${projectDetails.depth} mm`, 70, yPos);
                        yPos += 8;
                    }
                    
                    yPos += 15; // Space after project details box
                    
                    // Mix Preview (moved to appear after project details)
                    if (totalParts > 0 && canvasRef.current) {
                        doc.setFont('helvetica', 'bold');
                        doc.setFontSize(16);
                        doc.text('Granular Mix Preview', 20, yPos);
                        yPos += 10;
                        
                        // Add canvas as image with border
                        const canvas = canvasRef.current;
                        const imgData = canvas.toDataURL('image/jpeg', 0.9);
                        
                        // Background for image
                        doc.setFillColor(255, 255, 255);
                        doc.rect(20, yPos, 170, 85, 'F');
                        doc.setDrawColor(233, 236, 239);
                        doc.setLineWidth(1);
                        doc.rect(20, yPos, 170, 85, 'S');
                        
                        doc.addImage(imgData, 'JPEG', 22, yPos + 2, 166, 81);
                        yPos += 100;
                    }
                    
                    // Colour Mix Section
                    if (totalParts > 0) {
                        if (yPos > 200) {
                            doc.addPage();
                            yPos = 20;
                        }
                        
                        doc.setFont('helvetica', 'bold');
                        doc.setFontSize(16);
                        doc.text('Colour Specification', 20, yPos);
                        yPos += 10;
                        
                        // Individual colours table header (moved before average blend)
                        doc.setFont('helvetica', 'bold');
                        doc.setFontSize(12);
                        doc.text('Colour Breakdown:', 20, yPos);
                        yPos += 8;
                        
                        // Table headers with Quantity column
                        doc.setFillColor(26, 54, 93);
                        doc.rect(20, yPos, 170, 8, 'F');
                        doc.setTextColor(255, 255, 255);
                        doc.setFont('helvetica', 'bold');
                        doc.setFontSize(10);
                        doc.text('Colour', 25, yPos + 5);
                        doc.text('Code', 60, yPos + 5);
                        doc.text('%', 85, yPos + 5);
                        doc.text('Parts', 105, yPos + 5);
                        doc.text('Quantity (kg)', 130, yPos + 5);
                        doc.text('Swatch', 165, yPos + 5);
                        yPos += 10;
                        
                        doc.setTextColor(0, 0, 0);
                        
                        // Color rows with quantity data
                        let rowIndex = 0;
                        Array.from(parts.entries()).forEach(([colourIndex, count]) => {
                            const colour = PALETTE[colourIndex];
                            const percentage = Math.round((count / totalParts) * 100);
                            const quantity = Math.round((percentage / 100) * materialRequired);
                            
                            // Alternating row background
                            if (rowIndex % 2 === 0) {
                                doc.setFillColor(248, 249, 250);
                                doc.rect(20, yPos - 2, 170, 8, 'F');
                            }
                            
                            doc.setFont('helvetica', 'normal');
                            doc.setFontSize(9);
                            doc.text(colour.name, 25, yPos + 3);
                            doc.text(colour.code, 60, yPos + 3);
                            doc.text(`${percentage}%`, 85, yPos + 3);
                            doc.text(count.toString(), 105, yPos + 3);
                            doc.text(`${quantity} kg`, 130, yPos + 3);
                            
                            // Color swatch
                            drawColorSwatch(165, yPos, 15, 5, colour.hex);
                            
                            yPos += 8;
                            rowIndex++;
                        });
                        
                        // Add border around table
                        doc.setDrawColor(233, 236, 239);
                        doc.setLineWidth(0.5);
                        doc.rect(20, yPos - (rowIndex * 8) - 10, 170, (rowIndex * 8) + 10, 'S');
                        
                        yPos += 10;
                        doc.setFont('helvetica', 'bold');
                        doc.setFontSize(11);
                        doc.text(`Total Parts: ${totalParts}`, 20, yPos);
                        yPos += 8;
                        doc.setTextColor(33, 150, 243);
                        doc.text(`Total Material Required: ${materialRequired} kg`, 20, yPos);
                        doc.setTextColor(0, 0, 0);
                        yPos += 20;
                        
                        // Average blend colour with large swatch (moved after breakdown)
                        doc.setFont('helvetica', 'bold');
                        doc.setFontSize(12);
                        doc.text('Average Blend Colour:', 20, yPos);
                        yPos += 5;
                        
                        // Large swatch for blended color
                        drawColorSwatch(20, yPos, 40, 20, blendedColor);
                        doc.setFont('helvetica', 'normal');
                        doc.setFontSize(11);
                        doc.text(blendedColor, 65, yPos + 8);
                        doc.text(`RGB(${blendedRgb.r}, ${blendedRgb.g}, ${blendedRgb.b})`, 65, yPos + 16);
                        yPos += 35;
                        
                        // Mix code section
                        doc.setFont('helvetica', 'bold');
                        doc.setFontSize(12);
                        doc.text('Mix Code:', 20, yPos);
                        yPos += 5;
                        
                        // Mix code background
                        doc.setFillColor(248, 249, 250);
                        doc.rect(20, yPos, 170, 15, 'F');
                        doc.setDrawColor(233, 236, 239);
                        doc.setLineWidth(0.5);
                        doc.rect(20, yPos, 170, 15, 'S');
                        
                        doc.setFont('helvetica', 'normal');
                        doc.setFontSize(14);
                        doc.setTextColor(33, 150, 243);
                        doc.text(shareCode, 25, yPos + 10);
                        doc.setTextColor(0, 0, 0);
                        yPos += 20;
                        
                        doc.setFont('helvetica', 'normal');
                        doc.setFontSize(9);
                        doc.setTextColor(102, 102, 102);
                        doc.text('Use this code in the Rosehill TPV® Colour Mixer to recreate this exact mix.', 20, yPos);
                        doc.setTextColor(0, 0, 0);
                        yPos += 10;
                    }
                    
                    // Notes Section
                    if (projectDetails.notes) {
                        if (yPos > 220) {
                            doc.addPage();
                            yPos = 20;
                        }
                        
                        doc.setFont('helvetica', 'bold');
                        doc.setFontSize(16);
                        doc.text('Project Notes', 20, yPos);
                        yPos += 10;
                        
                        // Notes background
                        const notesHeight = Math.max(30, projectDetails.notes.length / 8);
                        doc.setFillColor(248, 249, 250);
                        doc.rect(20, yPos, 170, notesHeight, 'F');
                        doc.setDrawColor(233, 236, 239);
                        doc.setLineWidth(0.5);
                        doc.rect(20, yPos, 170, notesHeight, 'S');
                        
                        yPos += 8;
                        doc.setFont('helvetica', 'normal');
                        doc.setFontSize(11);
                        const splitNotes = doc.splitTextToSize(projectDetails.notes, 160);
                        doc.text(splitNotes, 25, yPos);
                    }
                    
                    // Footer on all pages
                    const pageCount = doc.internal.getNumberOfPages();
                    for (let i = 1; i <= pageCount; i++) {
                        doc.setPage(i);
                        
                        // Footer background
                        doc.setFillColor(248, 249, 250);
                        doc.rect(0, 285, 210, 12, 'F');
                        
                        doc.setTextColor(102, 102, 102);
                        doc.setFont('helvetica', 'normal');
                        doc.setFontSize(9);
                        doc.text('Generated by Rosehill TPV® Colour Mixer', 20, 292);
                        doc.text(`Page ${i} of ${pageCount}`, 160, 292);
                        doc.text(new Date().toLocaleDateString('en-GB'), 20, 295);
                        
                        // Orange footer stripe
                        doc.setFillColor(241, 91, 50);
                        doc.rect(0, 297, 210, 1, 'F');
                    }
                    
                    // Save the PDF with British spelling
                    const currentDate = new Date().toISOString().split('T')[0]; // YYYY-MM-DD format
                    const fileName = projectDetails.name ? 
                        `${projectDetails.name.replace(/[^a-z0-9]/gi, '_').toLowerCase()}_colour_mix_${currentDate}.pdf` : 
                        `rosehill_tpv_colour_mix_${currentDate}.pdf`;
                    doc.save(fileName);
                }, [projectDetails, totalParts, parts, blendedColor, blendedRgb, materialRequired, colorMaterials, canvasRef]);

                // Mouse handlers for panning
                const handleMouseDown = useCallback((e) => {
                    if (e.button === 0) { // Left mouse button
                        setIsPanning(true);
                        setLastMousePos({ x: e.clientX, y: e.clientY });
                    }
                }, []);

                const handleMouseMove = useCallback((e) => {
                    if (isPanning) {
                        const dx = e.clientX - lastMousePos.x;
                        const dy = e.clientY - lastMousePos.y;
                        setPanOffset(prev => {
                            const newOffset = {
                                x: prev.x + dx,
                                y: prev.y + dy
                            };
                            return constrainPanOffset(newOffset, zoomLevel);
                        });
                        setLastMousePos({ x: e.clientX, y: e.clientY });
                    }
                }, [isPanning, lastMousePos, constrainPanOffset, zoomLevel]);

                const handleMouseUp = useCallback(() => {
                    setIsPanning(false);
                }, []);

                // Add mouse event listeners to canvas
                useEffect(() => {
                    const canvas = canvasRef.current;
                    if (!canvas) return;

                    canvas.addEventListener('mousedown', handleMouseDown);
                    window.addEventListener('mousemove', handleMouseMove);
                    window.addEventListener('mouseup', handleMouseUp);

                    return () => {
                        canvas.removeEventListener('mousedown', handleMouseDown);
                        window.removeEventListener('mousemove', handleMouseMove);
                        window.removeEventListener('mouseup', handleMouseUp);
                    };
                }, [handleMouseDown, handleMouseMove, handleMouseUp]);

                // Keyboard shortcuts
                useEffect(() => {
                    const handleKeyPress = (e) => {
                        if (e.ctrlKey || e.metaKey) {
                            if (e.key === 'z' && !e.shiftKey) {
                                e.preventDefault();
                                undo();
                            } else if ((e.key === 'z' && e.shiftKey) || e.key === 'y') {
                                e.preventDefault();
                                redo();
                            }
                        }
                    };
                    window.addEventListener('keydown', handleKeyPress);
                    return () => window.removeEventListener('keydown', handleKeyPress);
                }, [undo, redo]);

                return React.createElement('div', { className: 'app' },
                    React.createElement('header', { className: 'app-header' },
                        React.createElement('h1', null, 
                            React.createElement('span', null, 'Rosehill TPV'),
                            React.createElement('sup', null, '®'),
                            React.createElement('span', null, ' Colour Mixer')
                        ),
                        React.createElement('p', { style: { fontFamily: "'Source Sans Pro', sans-serif" } }, 'Create custom granule blends with our 21 premium Rosehill TPV® colours')
                    ),

                    React.createElement('div', { className: 'main-content' },
                        React.createElement('div', { className: 'canvas-container' },
                            React.createElement('div', { className: 'canvas-wrapper' },
                                React.createElement('canvas', { 
                                    ref: canvasRef,
                                    style: { cursor: isPanning ? 'grabbing' : 'grab' }
                                }),
                                React.createElement('div', { className: 'zoom-controls' },
                                    React.createElement('button', {
                                        className: 'zoom-btn',
                                        onClick: zoomIn,
                                        disabled: zoomLevel >= 5,
                                        title: 'Zoom In',
                                        'aria-label': 'Zoom In'
                                    }, '+'),
                                    React.createElement('button', {
                                        className: 'zoom-btn',
                                        onClick: zoomOut,
                                        disabled: zoomLevel <= 0.5,
                                        title: 'Zoom Out',
                                        'aria-label': 'Zoom Out'
                                    }, '−'),
                                    React.createElement('button', {
                                        className: 'zoom-btn',
                                        onClick: resetCanvas,
                                        disabled: parts.size === 0 && zoomLevel === 2 && panOffset.x === 0 && panOffset.y === 0,
                                        title: 'Reset Canvas',
                                        'aria-label': 'Reset Canvas',
                                        style: { fontSize: '14px' }
                                    }, '⟲')
                                ),
                                isInitializing && React.createElement('div', { className: 'loading-overlay' }, 'Generating granules...')
                            )
                        ),

                        React.createElement('div', { className: 'palette-section' },
                            React.createElement('h2', { className: 'palette-title' }, 'Colour Palette'),
                                React.createElement('div', { className: 'palette-grid' },
                                    PALETTE.map((colour, index) => {
                                        const partCount = parts.get(index) || 0;
                                        return React.createElement('div', {
                                            key: index,
                                            className: 'colour-item'
                                        },
                                            React.createElement('button', {
                                                className: 'colour-swatch' + (partCount > 0 ? ' has-parts' : ''),
                                                style: { backgroundColor: colour.hex },
                                                onClick: () => addPart(index),
                                                'aria-label': `Add ${colour.name}`,
                                                title: colour.name
                                            }),
                                            React.createElement('div', { className: 'colour-info' },
                                                React.createElement('div', { className: 'colour-name' }, colour.name),
                                                React.createElement('div', { className: 'colour-code' }, colour.code)
                                            ),
                                            React.createElement('div', { className: 'parts-controls' },
                                                React.createElement('button', {
                                                    className: 'parts-btn',
                                                    onClick: () => removePart(index),
                                                    disabled: partCount === 0,
                                                    'aria-label': `Remove ${colour.name}`
                                                }, '−'),
                                                React.createElement('div', { className: 'parts-count' }, partCount),
                                                React.createElement('button', {
                                                    className: 'parts-btn',
                                                    onClick: () => addPart(index),
                                                    'aria-label': `Add ${colour.name}`
                                                }, '+')
                                            )
                                        );
                                    })
                                )
                        ),

                        React.createElement('div', { className: 'controls' },
                            React.createElement('div', { className: 'left-controls' },
                                React.createElement('div', { className: 'mix-bar-section' },
                                React.createElement('h2', { className: 'palette-title' }, 'Current Mix'),
                                React.createElement('div', { className: 'mix-bar' },
                                    totalParts === 0 
                                        ? React.createElement('div', { className: 'mix-bar-segment mix-bar-empty' }, 'Empty canvas')
                                        : Array.from(percentages.entries()).map(([colourIndex, percentage]) =>
                                            React.createElement('div', {
                                                key: colourIndex,
                                                className: 'mix-bar-segment',
                                                style: {
                                                    backgroundColor: PALETTE[colourIndex].hex,
                                                    flexBasis: `${percentage}%`
                                                }
                                            }, percentage >= 10 && `${Math.round(percentage)}%`)
                                        )
                                ),
                                totalParts > 0 && React.createElement('div', { className: 'mix-details' },
                                    Array.from(parts.entries()).map(([colourIndex, count]) =>
                                        React.createElement('div', { key: colourIndex, className: 'mix-detail-item' },
                                            React.createElement('div', {
                                                className: 'mix-detail-colour',
                                                style: { backgroundColor: PALETTE[colourIndex].hex }
                                            }),
                                            React.createElement('span', { className: 'mix-detail-text' },
                                                `${PALETTE[colourIndex].name} (${PALETTE[colourIndex].code}): ${Math.round(percentages.get(colourIndex))}% (${count} ${count === 1 ? 'part' : 'parts'})`
                                            )
                                        )
                                    )
                                )
                            ),

                                React.createElement('div', { className: 'action-buttons' },
                                React.createElement('button', { className: 'btn', onClick: undo, disabled: undoStack.length === 0 }, 'Undo'),
                                React.createElement('button', { className: 'btn', onClick: redo, disabled: redoStack.length === 0 }, 'Redo'),
                                React.createElement('button', { className: 'btn btn-secondary', onClick: clear, disabled: parts.size === 0 }, 'Clear'),
                                React.createElement('button', { className: 'btn', onClick: exportPNG, disabled: parts.size === 0 }, 'Export PNG')
                                ),
                                
                                React.createElement('div', { className: 'project-details-section' },
                                    React.createElement('h2', { className: 'palette-title' }, 'Project Details'),
                                    React.createElement('div', { className: 'form-grid' },
                                        React.createElement('div', { className: 'form-field' },
                                            React.createElement('label', { className: 'form-label' }, 'Project Name'),
                                            React.createElement('input', {
                                                type: 'text',
                                                className: 'form-input',
                                                value: projectDetails.name,
                                                onChange: (e) => setProjectDetails(prev => ({ ...prev, name: e.target.value }))
                                            })
                                        ),
                                        React.createElement('div', { className: 'form-field' },
                                            React.createElement('label', { className: 'form-label' }, 'Location'),
                                            React.createElement('input', {
                                                type: 'text',
                                                className: 'form-input',
                                                value: projectDetails.location,
                                                onChange: (e) => setProjectDetails(prev => ({ ...prev, location: e.target.value }))
                                            })
                                        ),
                                        React.createElement('div', { className: 'form-field' },
                                            React.createElement('label', { className: 'form-label' }, 'Area (m²)'),
                                            React.createElement('input', {
                                                type: 'number',
                                                className: 'form-input',
                                                value: projectDetails.area,
                                                onChange: (e) => setProjectDetails(prev => ({ ...prev, area: e.target.value })),
                                                min: '0',
                                                step: '0.1'
                                            })
                                        ),
                                        React.createElement('div', { className: 'form-field' },
                                            React.createElement('label', { className: 'form-label' }, 'Depth (mm)'),
                                            React.createElement('select', {
                                                className: 'form-input',
                                                value: projectDetails.depth,
                                                onChange: (e) => setProjectDetails(prev => ({ ...prev, depth: e.target.value }))
                                            },
                                                React.createElement('option', { value: '' }, 'Select depth...'),
                                                React.createElement('option', { value: '10' }, '10mm'),
                                                React.createElement('option', { value: '15' }, '15mm'),
                                                React.createElement('option', { value: '20' }, '20mm'),
                                                React.createElement('option', { value: '25' }, '25mm')
                                            )
                                        ),
                                        React.createElement('div', { className: 'form-field full-width' },
                                            React.createElement('label', { className: 'form-label' }, 'Notes'),
                                            React.createElement('textarea', {
                                                className: 'form-textarea',
                                                value: projectDetails.notes,
                                                onChange: (e) => setProjectDetails(prev => ({ ...prev, notes: e.target.value })),
                                                placeholder: 'Additional project notes, specifications, or requirements...'
                                            })
                                        )
                                    ),
                                    materialRequired > 0 && React.createElement('div', { className: 'material-calc' },
                                        React.createElement('h4', null, 'Material Calculation'),
                                        totalParts > 0 && colorMaterials.length > 0 && React.createElement('div', { className: 'color-materials-breakdown' },
                                            colorMaterials.map(colorMaterial => 
                                                React.createElement('div', { 
                                                    key: colorMaterial.colorIndex,
                                                    className: 'color-material-item'
                                                },
                                                    React.createElement('div', { className: 'color-material-info' },
                                                        React.createElement('div', {
                                                            className: 'color-material-swatch',
                                                            style: { backgroundColor: colorMaterial.hex }
                                                        }),
                                                        React.createElement('span', { className: 'color-material-name' },
                                                            `${colorMaterial.name} (${colorMaterial.code})`
                                                        )
                                                    ),
                                                    React.createElement('div', null,
                                                        React.createElement('span', { className: 'color-material-quantity' },
                                                            `${colorMaterial.quantity} kg`
                                                        ),
                                                        React.createElement('span', { className: 'color-material-percentage' },
                                                            `(${colorMaterial.percentage}%)`
                                                        )
                                                    )
                                                )
                                            )
                                        ),
                                        React.createElement('div', { className: 'material-total' },
                                            `Total Required: ${materialRequired} kg`
                                        ),
                                        React.createElement('div', { style: { fontSize: '0.85rem', color: '#666', marginTop: '8px', textAlign: 'center' } },
                                            `Based on ${projectDetails.area}m² area at ${projectDetails.depth}mm depth`
                                        )
                                    ),
                                    React.createElement('button', {
                                        className: 'btn-pdf',
                                        onClick: generatePDF,
                                        disabled: !projectDetails.name && totalParts === 0
                                    }, '📄 Save as PDF')
                                )
                            ),
                            
                            React.createElement('div', { className: 'right-controls' },
                                React.createElement(TilePreview, {
                                    canvasRef: canvasRef,
                                    parts: parts,
                                    totalParts: totalParts
                                }),
                                totalParts > 0 && React.createElement('div', { className: 'blend-preview-section' },
                                    React.createElement('h2', { className: 'palette-title' }, 'Average Blend Colour'),
                                    React.createElement('div', {
                                        className: 'blend-preview-swatch',
                                        style: { 
                                            backgroundColor: blendedColor,
                                            color: getContrastColor(blendedColor)
                                        },
                                        onClick: () => {
                                            navigator.clipboard.writeText(blendedColor);
                                            setTooltip({ text: 'Colour copied!', x: window.innerWidth / 2, y: 100 });
                                            setTimeout(() => setTooltip(null), 2000);
                                        },
                                        title: 'Click to copy hex code'
                                    }, blendedColor),
                                    React.createElement('div', { className: 'blend-details' },
                                        React.createElement('div', { className: 'blend-detail-row' },
                                            React.createElement('span', { className: 'blend-detail-label' }, 'Hex:'),
                                            React.createElement('span', { className: 'blend-detail-value' }, blendedColor)
                                        ),
                                        React.createElement('div', { className: 'blend-detail-row' },
                                            React.createElement('span', { className: 'blend-detail-label' }, 'RGB:'),
                                            React.createElement('span', { className: 'blend-detail-value' }, 
                                                `rgb(${blendedRgb.r}, ${blendedRgb.g}, ${blendedRgb.b})`
                                            )
                                        ),
                                        React.createElement('div', { style: { 
                                            fontSize: '0.75rem', 
                                            color: '#666', 
                                            marginTop: '10px',
                                            fontStyle: 'italic',
                                            lineHeight: '1.3'
                                        }}, 
                                            'This shows the weighted average of all colours in the mix. Useful for quick colour matching.'
                                        )
                                    )
                                ),
                                React.createElement('div', { className: 'share-section' },
                                React.createElement('h2', { className: 'palette-title' }, 'Share Mix'),
                                React.createElement('div', { style: { marginBottom: '15px' } },
                                    React.createElement('label', { className: 'form-label', style: { marginBottom: '5px', display: 'block' } }, 'Your Mix Code'),
                                    React.createElement('input', {
                                        type: 'text',
                                        className: 'share-input',
                                        value: shareCode,
                                        readOnly: true,
                                        onClick: (e) => e.target.select(),
                                        style: { marginBottom: '5px' }
                                    }),
                                    React.createElement('button', { className: 'btn', onClick: copyShareCode }, 'Copy Code')
                                ),
                                React.createElement('div', null,
                                    React.createElement('label', { className: 'form-label', style: { marginBottom: '5px', display: 'block' } }, 'Load Mix Code'),
                                    React.createElement('div', { className: 'share-input-group' },
                                        React.createElement('input', {
                                            type: 'text',
                                            className: 'share-input share-input-field',
                                            value: shareInput,
                                            onChange: (e) => {
                                                setShareInput(e.target.value);
                                                setShareError('');
                                            },
                                            placeholder: 'Enter a mix code...',
                                            style: { marginBottom: shareError ? '5px' : '0' }
                                        }),
                                        React.createElement('button', {
                                            className: 'btn btn-load',
                                            onClick: loadShareCode,
                                            disabled: !shareInput.trim()
                                        }, 'Load')
                                    ),
                                    shareError && React.createElement('div', { className: 'share-error' }, shareError)
                                )
                                )
                            )
                        )
                    ),

                    tooltip && React.createElement('div', {
                        className: 'tooltip',
                        style: {
                            left: tooltip.x + 'px',
                            top: tooltip.y + 'px',
                            transform: 'translate(-50%, -50%)'
                        }
                    }, tooltip.text)
                );
            }

            // Render the app
            ReactDOM.render(React.createElement(App), document.getElementById('root'));
        });

        // Header navigation functionality
        // Enhanced scroll effect for header
        window.addEventListener('scroll', function() {
            const header = document.querySelector('.header');
            if (window.scrollY > 100) {
                header.style.background = 'linear-gradient(135deg, rgba(26, 54, 93, 0.98), rgba(45, 74, 113, 0.98))';
                header.style.backdropFilter = 'blur(10px)';
                header.style.boxShadow = '0 8px 32px rgba(0,0,0,0.15)';
            } else {
                header.style.background = 'linear-gradient(135deg, #1a365d, #2d4a71)';
                header.style.backdropFilter = 'none';
                header.style.boxShadow = '0 2px 10px rgba(0,0,0,0.1)';
            }
        });

        // Mobile menu toggle functionality
        const mobileToggle = document.getElementById('mobile-toggle');
        const mobileMenu = document.getElementById('mobile-menu');

        if (mobileToggle && mobileMenu) {
            mobileToggle.addEventListener('click', function() {
                mobileToggle.classList.toggle('active');
                mobileMenu.classList.toggle('active');
            });

            // Close mobile menu when clicking on a link
            document.querySelectorAll('.mobile-nav-menu a').forEach(link => {
                link.addEventListener('click', function() {
                    mobileToggle.classList.remove('active');
                    mobileMenu.classList.remove('active');
                });
            });

            // Close mobile menu when clicking outside
            document.addEventListener('click', function(event) {
                if (!mobileToggle.contains(event.target) && !mobileMenu.contains(event.target)) {
                    mobileToggle.classList.remove('active');
                    mobileMenu.classList.remove('active');
                }
            });
        }

        // Smooth scrolling for navigation links (exclude language dropdown)
        document.querySelectorAll('a[href^="#"]:not(.language-dropdown-toggle)').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                const href = this.getAttribute('href');
                if (href === '#') return; // Skip empty anchors
                
                e.preventDefault();
                const target = document.querySelector(href);
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });
    </script>
    <!-- Client-side translation system -->

    <!-- Analytics Language Enhancement -->
    <script src="/analytics-language-enhancer.js"></script>

    <script>
        // Desktop Language Dropdown functionality
        const languageToggle = document.getElementById('language-dropdown-toggle');
        const languageDropdown = document.getElementById('language-dropdown');

        if (languageToggle && languageDropdown) {
            languageToggle.addEventListener('click', function(event) {
                event.preventDefault();
                event.stopPropagation();
                languageToggle.classList.toggle('active');
                languageDropdown.classList.toggle('active');
            });

            // Close dropdown when clicking outside
            document.addEventListener('click', function(event) {
                if (!languageToggle.contains(event.target) && !languageDropdown.contains(event.target)) {
                    languageToggle.classList.remove('active');
                    languageDropdown.classList.remove('active');
                }
            });

            // Prevent dropdown from closing when clicking inside
            languageDropdown.addEventListener('click', function(event) {
                event.stopPropagation();
            });
        }
    </script>

    <!-- Language Switcher Handler -->
    <script>
            <script>
        function initLanguageSwitcher() {
            const path = window.location.pathname;
            const langMatch = path.match(/^\/(?:es|fr|de)\//);
            const currentLang = langMatch ? langMatch[0].slice(1, -1) : 'en';
            
            // Extract base page path without language prefix
            let basePage = path;
            if (langMatch) {
                basePage = path.replace(/^\/(?:es|fr|de)/, '');
            }
            if (basePage === '' || basePage === '/') {
                basePage = '/index.html';
            }
            if (!basePage.startsWith('/')) {
                basePage = '/' + basePage;
            }
            
            // Update desktop dropdown toggle
            const dropdownToggle = document.getElementById('language-dropdown-toggle');
            if (dropdownToggle) {
                dropdownToggle.textContent = currentLang.toUpperCase();
            }
            
            // Set active states and add click handlers for desktop dropdown
            document.querySelectorAll('.language-dropdown .lang-option').forEach(link => {
                const targetLang = link.getAttribute('data-lang');
                
                // Set active state
                link.classList.remove('active');
                if (targetLang === currentLang) {
                    link.classList.add('active');
                }
                
                // Add click handler
                link.addEventListener('click', function(e) {
                    e.preventDefault();
                    
                    let targetUrl;
                    if (targetLang === 'en') {
                        targetUrl = basePage;
                    } else {
                        targetUrl = `/${targetLang}${basePage}`;
                    }
                    
                    // Navigate to the new URL
                    window.location.href = targetUrl;
                });
            });
            
            // Set active states and add click handlers for mobile switcher
            document.querySelectorAll('.mobile-language-switcher a').forEach(link => {
                const targetLang = link.getAttribute('data-lang');
                
                // Reset styles
                link.classList.remove('active');
                
                // Set active state
                if (targetLang === currentLang) {
                    link.classList.add('active');
                }
                
                // Add click handler
                link.addEventListener('click', function(e) {
                    e.preventDefault();
                    
                    let targetUrl;
                    if (targetLang === 'en') {
                        targetUrl = basePage;
                    } else {
                        targetUrl = `/${targetLang}${basePage}`;
                    }
                    
                    // Navigate to the new URL
                    window.location.href = targetUrl;
                });
            });
        }
        
        document.addEventListener('DOMContentLoaded', initLanguageSwitcher);
    </script>
    <script src="/i18n/translate-client.js"></script>
</body>
</html>