// TPV Studio - Sports Surface Export Utilities
// Client-side SVG and PNG export functionality

/**
 * Get SVG content from the sports surface canvas
 * @param {SVGElement} svgElement - The SVG element from CourtCanvas
 * @param {Object} state - Design state from store
 * @returns {string} SVG content as string
 */
export function generateSportsSVG(svgElement, state) {
  if (!svgElement) {
    throw new Error('SVG element not found');
  }

  // Clone the SVG element to avoid modifying the original
  const clonedSvg = svgElement.cloneNode(true);

  // Remove selection indicators and transform handles
  const selectionElements = clonedSvg.querySelectorAll(
    '.court-canvas__selection-outline, .transform-handles, [class*="selection"], [class*="handle"]'
  );
  selectionElements.forEach(el => el.remove());

  // Clean up any dashed selection borders
  const selectedElements = clonedSvg.querySelectorAll('[stroke-dasharray]');
  selectedElements.forEach(el => {
    if (el.getAttribute('stroke-dasharray')) {
      el.remove();
    }
  });

  // Add metadata
  const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
  title.textContent = state?.name || 'Sports Surface Design';
  clonedSvg.insertBefore(title, clonedSvg.firstChild);

  const desc = document.createElementNS('http://www.w3.org/2000/svg', 'desc');
  desc.textContent = `Generated by TPV Studio - Sports Surface Designer. Dimensions: ${(state?.surface?.width_mm / 1000).toFixed(1)}m Ã— ${(state?.surface?.length_mm / 1000).toFixed(1)}m`;
  clonedSvg.insertBefore(desc, clonedSvg.firstChild.nextSibling);

  // Set proper SVG attributes for standalone file
  clonedSvg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
  clonedSvg.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');

  // Add physical dimensions using mm units
  const widthMm = state?.surface?.width_mm || 50000;
  const heightMm = state?.surface?.length_mm || 50000;
  clonedSvg.setAttribute('width', `${widthMm}mm`);
  clonedSvg.setAttribute('height', `${heightMm}mm`);

  // Add TPV Studio marker
  clonedSvg.setAttribute('data-tpv-studio', '1.0');
  clonedSvg.setAttribute('data-design-type', 'sports_surface');

  // Serialize to string
  const serializer = new XMLSerializer();
  let svgString = serializer.serializeToString(clonedSvg);

  // Add XML declaration
  svgString = '<?xml version="1.0" encoding="UTF-8"?>\n' + svgString;

  return svgString;
}

/**
 * Download SVG as a file
 * @param {string} svgContent - SVG string content
 * @param {string} filename - Desired filename
 */
export function downloadSVG(svgContent, filename = 'sports-surface.svg') {
  const blob = new Blob([svgContent], { type: 'image/svg+xml' });
  const url = URL.createObjectURL(blob);

  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);

  URL.revokeObjectURL(url);
}

/**
 * Convert SVG to PNG and download
 * @param {SVGElement} svgElement - The SVG element
 * @param {Object} state - Design state
 * @param {string} filename - Desired filename
 * @param {number} scale - Scale factor for resolution (default 2 for retina)
 * @returns {Promise<void>}
 */
export async function downloadPNG(svgElement, state, filename = 'sports-surface.png', scale = 2) {
  return new Promise((resolve, reject) => {
    try {
      // Get SVG content
      const svgContent = generateSportsSVG(svgElement, state);

      // Create canvas
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');

      // Calculate canvas size based on SVG viewBox
      const viewBox = svgElement.getAttribute('viewBox');
      let canvasWidth = 1200;
      let canvasHeight = 1200;

      if (viewBox) {
        const [, , vbWidth, vbHeight] = viewBox.split(' ').map(Number);
        // Maintain aspect ratio, max width 2400px
        const maxWidth = 2400;
        const aspectRatio = vbHeight / vbWidth;
        canvasWidth = Math.min(vbWidth / 10, maxWidth); // Convert mm to reasonable pixels
        canvasHeight = canvasWidth * aspectRatio;
      }

      canvas.width = canvasWidth * scale;
      canvas.height = canvasHeight * scale;

      // Create image from SVG
      const img = new Image();
      const svgBlob = new Blob([svgContent], { type: 'image/svg+xml;charset=utf-8' });
      const url = URL.createObjectURL(svgBlob);

      img.onload = () => {
        // Draw white background
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw SVG
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

        // Convert to blob and download
        canvas.toBlob((blob) => {
          if (!blob) {
            reject(new Error('Failed to create PNG blob'));
            return;
          }

          const downloadUrl = URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = downloadUrl;
          link.download = filename;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);

          URL.revokeObjectURL(url);
          URL.revokeObjectURL(downloadUrl);
          resolve();
        }, 'image/png', 0.95);
      };

      img.onerror = (err) => {
        URL.revokeObjectURL(url);
        reject(new Error('Failed to load SVG for PNG conversion'));
      };

      img.src = url;
    } catch (error) {
      reject(error);
    }
  });
}

/**
 * Generate a sanitized filename from design name
 * @param {string} name - Design name
 * @param {string} extension - File extension (without dot)
 * @returns {string} Sanitized filename
 */
export function generateFilename(name, extension) {
  const sanitized = (name || 'sports-surface')
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '')
    .substring(0, 50);

  const timestamp = new Date().toISOString().split('T')[0];
  return `${sanitized}_${timestamp}.${extension}`;
}
